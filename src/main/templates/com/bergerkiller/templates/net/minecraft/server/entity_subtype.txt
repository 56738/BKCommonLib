package net.minecraft.server;

import com.bergerkiller.bukkit.common.bases.IntVector3;
import com.bergerkiller.bukkit.common.wrappers.DataWatcher;
import com.bergerkiller.bukkit.common.wrappers.DataWatcher.Key;
import com.bergerkiller.bukkit.common.wrappers.ChatText;

import com.bergerkiller.generated.com.mojang.authlib.GameProfileHandle;

import com.bergerkiller.generated.net.minecraft.server.MobEffectHandle;
import com.bergerkiller.generated.net.minecraft.server.MobEffectListHandle;
import com.bergerkiller.generated.net.minecraft.server.AttributeMapBaseHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityPlayerHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityItemHandle;
import com.bergerkiller.generated.net.minecraft.server.WorldHandle;
import com.bergerkiller.generated.net.minecraft.server.ItemStackHandle;
import com.bergerkiller.generated.net.minecraft.server.AttributeModifiableHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityItemFrameHandle;
import com.bergerkiller.generated.net.minecraft.server.ContainerHandle;
import com.bergerkiller.generated.net.minecraft.server.PlayerConnectionHandle;

class EntityLiving extends Entity {

#if version >= 1.16
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:an;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:f;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:g;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:bo;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:bq;
#elseif version >= 1.15
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:ao;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:e;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:f;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:g;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:bq;
#elseif version >= 1.14
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:ar;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:e;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:f;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:g;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:bs;
#elseif version >= 1.13
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:aw;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:g;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:h;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:bx;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#elseif version >= 1.12
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:at;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:g;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:h;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:br;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#elseif version >= 1.11
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:at;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:g;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:h;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:bq;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#elseif version >= 1.10.2
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:au;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:f;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:g;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:h;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#elseif version >= 1.9.4
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:at;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:f;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:g;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:h;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#elseif version >= 1.9
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:as;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:HEALTH;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:f;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:g;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:h;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#else
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_LIVING_FLAGS:###;
    public static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_HEALTH:###;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_PARTICLES_TIMER:###;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_PARTICLES_HIDDEN:###;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_ARROWCOUNT:###;
    private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<Optional<BlockPosition>> DATA_BEDPOSITION:###;
#endif

    <code>
    public static final Key<Byte> DATA_LIVING_FLAGS = Key.Type.BYTE.createKey(T.DATA_LIVING_FLAGS, -1);
    public static final Key<Float> DATA_HEALTH = Key.Type.FLOAT.createKey(T.DATA_HEALTH, 6);
    public static final Key<Integer> DATA_PARTICLES_TIMER = Key.Type.INTEGER.createKey(T.DATA_PARTICLES_TIMER, 7);
    public static final Key<Boolean> DATA_PARTICLES_HIDDEN = Key.Type.BOOLEAN.createKey(T.DATA_PARTICLES_HIDDEN, 8);
    public static final Key<Integer> DATA_UNKNOWN1 = Key.Type.INTEGER.createKey(T.DATA_ARROWCOUNT, 9);
    public static final Key<IntVector3> DATA_BEDPOSITION = Key.Type.BLOCK_POSITION.createKey(T.DATA_BEDPOSITION, -1);
    </code>

    public void resetAttributes() {
#if version >= 1.16
        // Is only set in constructor, so we'll have to force it
        // TODO: Is there no cleaner way to do this? Maybe modify AttributeMapBase directly?
        #require net.minecraft.server.EntityLiving private final AttributeMapBase attributeMapField:attributeMap;
        #require net.minecraft.server.EntityLiving private final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
        AttributeMapBase new_attributes = new AttributeMapBase(AttributeDefaults.a(instance.getEntityType()));
        org.bukkit.craftbukkit.attribute.CraftAttributeMap new_craftAttributes = new org.bukkit.craftbukkit.attribute.CraftAttributeMap(new_attributes);
        instance#attributeMapField = new_attributes;
        instance#craftAttributes = new_craftAttributes;
#else
        // Set attributeMapField to null and call getAttributeMap()
        // This will initialize the field (and possibly related CraftAttributeMap >= 1.11)
        #if version >= 1.11
            #require net.minecraft.server.EntityLiving private AttributeMapBase attributeMapField:attributeMap;
        #elseif version >= 1.10.2
            #require net.minecraft.server.EntityLiving private AttributeMapBase attributeMapField:br;
        #elseif version >= 1.9.4
            #require net.minecraft.server.EntityLiving private AttributeMapBase attributeMapField:bq;
        #elseif version >= 1.9
            #require net.minecraft.server.EntityLiving private AttributeMapBase attributeMapField:bp;
        #else
            #require net.minecraft.server.EntityLiving private AttributeMapBase attributeMapField:c;
        #endif
        instance#attributeMapField = null;
        instance.getAttributeMap();

        // Then call initAttributes() to initialize the values used by the entity
        #if version >= 1.8.3
            #require net.minecraft.server.EntityLiving protected void initAttributes();
        #else
            #require net.minecraft.server.EntityLiving protected void initAttributes:aW();
        #endif
        instance#initAttributes();
#endif
    }

    public (AttributeMapBaseHandle) AttributeMapBase getAttributeMap();

#if version >= 1.16
    public (AttributeModifiableHandle) AttributeModifiable getAttribute:getAttributeInstance((Object) AttributeBase iattribute);
#else
    public (AttributeModifiableHandle) AttributeModifiable getAttribute((Object) IAttribute iattribute) {
        return (AttributeModifiable) instance.getAttributeInstance(iattribute);
    }
#endif

#if version >= 1.9
    public final (Map<MobEffectListHandle, MobEffectHandle>) Map<MobEffectList, MobEffect> mobEffects:effects;
#else
    public final (Map<MobEffectListHandle, MobEffectHandle>) Map<Integer, MobEffect> mobEffects:effects;
#endif

    public float lastDamage;

#if version >= 1.16
    protected unknown boolean jumping;
    public float sideMovement:aY;
    public unknown float aZ;
    public float forwardMovement:ba;
#elseif version >= 1.15
    protected unknown boolean jumping;
    public float sideMovement:aZ;
    public unknown float ba;
    public float forwardMovement:bb;
#elseif version >= 1.14
    protected unknown boolean jumping;
    public float sideMovement:bb;
    public unknown float bc;
    public float forwardMovement:bd;
    public unknown float be;
#elseif version >= 1.13
    protected unknown boolean bg;
    public float sideMovement:bh;
    public unknown float bi;
    public float forwardMovement:bj;
    public unknown float bk;
#elseif version >= 1.12
    protected unknown boolean bd;
    public float sideMovement:be;
    public unknown float bf;
    public float forwardMovement:bg;
    public unknown float bh;
#elseif version >= 1.11
    protected unknown boolean bd;
    public float sideMovement:be;
    public float forwardMovement:bf;
    public unknown float bg;
#elseif version >= 1.10.2
    protected unknown boolean be;
    public float sideMovement:bf;
    public float forwardMovement:bg;
    public unknown float bh;
#elseif version >= 1.9.4
    protected unknown boolean bd;
    public float sideMovement:be;
    public float forwardMovement:bf;
    public unknown float bg;
#elseif version >= 1.9
    protected unknown boolean bc;
    public float sideMovement:bd;
    public float forwardMovement:be;
    public unknown float bf;
#elseif version >= 1.8.3
    protected unknown boolean aY;
    public float sideMovement:aZ;
    public float forwardMovement:ba;
    protected unknown float bb;
#else
    protected unknown boolean aW;
    public float sideMovement:aX;
    public float forwardMovement:aY;
    protected unknown float aZ;
#endif

    public boolean updateEffects;

    public (Collection<MobEffectHandle>) Collection<MobEffect> getEffects();

#if version >= 1.9
    public abstract (org.bukkit.inventory.ItemStack) ItemStack getEquipment((org.bukkit.inventory.EquipmentSlot) EnumItemSlot paramEnumItemSlot);
#else
    public abstract (org.bukkit.inventory.ItemStack) ItemStack getEquipment((org.bukkit.inventory.EquipmentSlot) int paramEnumItemSlot);
#endif

    public final float getHealth();

    public final float getMaxHealth();

    <code>
    public static EntityLivingHandle fromBukkit(org.bukkit.entity.LivingEntity livingEntity) {
        return createHandle(com.bergerkiller.bukkit.common.conversion.type.HandleConversion.toEntityHandle(livingEntity));
    }
    </code>
}

class EntityHuman extends EntityLiving {
    public (Object) PlayerInventory inventoryRaw:inventory;
#if version >= 1.12
    protected (Object) InventoryEnderChest enderChestRaw:enderChest;
#else
    private (Object) InventoryEnderChest enderChestRaw:enderChest;
#endif
    public (ContainerHandle) Container activeContainer;
    protected (Object) FoodMetaData foodDataRaw:foodData;

    // Bed position is datawatcher value on 1.14
    // Do we actually use this field?
    //#if version >= 1.9
    //    public (IntVector3) BlockPosition bedPosition;
    //#elseif version >= 1.8.3
    //    public (IntVector3) BlockPosition bedPosition:bx;
    //#else
    //    public (IntVector3) BlockPosition bedPosition:bv;
    //#endif

    public int sleepTicks;

    public (com.bergerkiller.bukkit.common.wrappers.PlayerAbilities) PlayerAbilities abilities;
    public int expLevel;
    public int expTotal;
    public float exp;

#if version >= 1.16
    protected unknown int bN;
    protected unknown final float bO;
    private unknown int g;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bQ;
#elseif version >= 1.15
    protected unknown int bO;
    protected unknown final float bP;
    private unknown int bS;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bT;
#elseif version >= 1.14.4
    protected unknown int bR;
    protected unknown final float bS;
    private unknown int bV;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bW;
#elseif version >= 1.14
    protected unknown int bR;
    protected unknown final float bS;
    private unknown int bU;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bV;
#elseif version >= 1.13
    protected unknown int bZ;
    protected unknown float ca;
    private unknown int g;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:h;
#elseif version >= 1.12
    protected unknown int bS;
    protected unknown float bT;
    private unknown int f;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:g;
#elseif version >= 1.11
    private unknown int h;
    protected unknown float bO;
    protected unknown float bP;
    private unknown int bR;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bS;
#elseif version >= 1.10.2
    private unknown int h;
    protected unknown float bP;
    protected unknown float bQ;
    private unknown int bS;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bT;
#elseif version >= 1.9.4
    private unknown int h;
    protected unknown float bO;
    protected unknown float bP;
    private unknown int bR;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bS;
#elseif version >= 1.9
    private unknown int h;
    protected unknown float bN;
    protected unknown float bO;
    private unknown int bQ;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bR;
#elseif version >= 1.8.3
    private unknown int f;
    private unknown ItemStack g;
    private unknown int h;
    protected unknown float bE;
    protected unknown float bF;
    private unknown int i;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bH;
#else
    private unknown int f;
    private unknown ItemStack g;
    private unknown int h;
    protected unknown float bC;
    protected unknown float bD;
    private unknown int i;
    private final (GameProfileHandle) com.mojang.authlib.GameProfile gameProfile:bF;
#endif

    public void attack((org.bukkit.entity.Entity) Entity entity);
}

class EntityPlayer extends EntityHuman {
    public (PlayerConnectionHandle) PlayerConnection playerConnection;
    // public double chunkSyncX:d; // TODO: Used? is 'cv' Section coords on 1.14
    // public double chunkSyncZ:e; // TODO: Used? is 'cv' Section coords on 1.14

#if version >= 1.16
    #require net.minecraft.server.EntityPlayer private BlockPosition spawnCoord:spawn;
    #require net.minecraft.server.EntityPlayer private boolean spawnForced;
#elseif version >= 1.15
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:g;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:bR;
#elseif version >= 1.14.4
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:g;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:bU;
#elseif version >= 1.14
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:f;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:g;
#elseif version >= 1.13
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:e;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:f;
#elseif version >= 1.12
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:d;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:e;
#elseif version >= 1.11
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:e;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:f;
#elseif version >= 1.10.2
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:e;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:f;
#elseif version >= 1.9.4
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:e;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:f; 
#elseif version >= 1.9
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:e;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:f;
#elseif version >= 1.8.3
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:c;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:d;
#else
    #require net.minecraft.server.EntityHuman private BlockPosition spawnCoord:c;
    #require net.minecraft.server.EntityHuman private boolean spawnForced:d;
#endif

    public (IntVector3) BlockPosition getSpawnCoord() {
        return instance#spawnCoord;
    }

    public void setSpawnCoord((IntVector3) BlockPosition coord) {
        instance#spawnCoord = coord;
    }

    public boolean isSpawnForced() {
        return instance#spawnForced;
    }

    public void setSpawnForced(boolean forced) {
        instance#spawnForced = forced;
    }

    public int ping;

#if version >= 1.16
    // World dimension on 1.16 and later
    public org.bukkit.World getSpawnWorld() {
        ResourceKey spawn = instance.getSpawnDimension();
        World world = MinecraftServer.getServer().getWorldServer(spawn);
        return (world == null) ? null : world.getWorld();
    }
    public void setSpawnWorld(org.bukkit.World world) {
        #require net.minecraft.server.EntityPlayer private ResourceKey<World> spawnDimension;
        ResourceKey key = (world == null) ? World.OVERWORLD : ((org.bukkit.craftbukkit.CraftWorld) world).getHandle().getDimensionKey();
        instance#spawnDimension = key;
    }
#else
    // World name on 1.15.2 and earlier
    public org.bukkit.World getSpawnWorld() {
        return org.bukkit.Bukkit.getWorld(instance.spawnWorld);
    }
    public void setSpawnWorld(org.bukkit.World world) {
        instance.spawnWorld = (world == null) ? "" : world.getName();
    }
#endif

#if forge
    public void sendMessage:a((ChatText) IChatBaseComponent ichatbasecomponent);
#elseif version >= 1.16
    public void sendMessage((ChatText) IChatBaseComponent ichatbasecomponent) {
        instance.sendMessage(ichatbasecomponent, SystemUtils.b);
    }
#else
    public void sendMessage((ChatText) IChatBaseComponent ichatbasecomponent);
#endif

#if exists net.minecraft.server.EntityPlayer public final java.util.List<Integer> removeQueue;
    public optional Collection<Integer> getRemoveQueue() {
        return instance.removeQueue;
    }
#elseif exists net.minecraft.server.EntityPlayer public final java.util.Deque<Integer> removeQueue;
    public optional Collection<Integer> getRemoveQueue() {
        return instance.removeQueue;
    }
#else
    public optional Collection<Integer> getRemoveQueue:###();
#endif

    public org.bukkit.inventory.InventoryView openAnvilWindow() {
        String titleStr = (String) com.bergerkiller.generated.net.minecraft.server.BlockHandle.T.getTitle.invoke(Blocks.ANVIL);
        IChatBaseComponent title = new ChatMessage(titleStr, new Object[0]);

        PlayerInventory playerInventory = instance.inventory;
        World world = instance.getWorld();
        BlockPosition position = instance.getChunkCoordinates();

        int windowId = instance.nextContainerCounter();

#if version >= 1.14
        ContainerAccess access = ContainerAccess.at(world, position);
        ContainerAnvil container = new ContainerAnvil(windowId, playerInventory, access);
#else
        ContainerAnvil container = new ContainerAnvil(playerInventory, world, position, instance);
        container.windowId = windowId;
#endif
        container.checkReachable = false;

        // Hook required so we can track when the text changes
#if version < 1.9
        com.bergerkiller.bukkit.common.internal.hooks.LegacyContainerAnvilHook hook;
        hook = new com.bergerkiller.bukkit.common.internal.hooks.LegacyContainerAnvilHook();
        container = (ContainerAnvil) hook.hook(container);
#endif

        instance.activeContainer = container;

#if version >= 1.14
        instance.playerConnection.sendPacket(new PacketPlayOutOpenWindow(windowId, Containers.ANVIL, title));
#else
        instance.playerConnection.sendPacket(new PacketPlayOutOpenWindow(windowId, "minecraft:anvil", title));
#endif

        instance.activeContainer.addSlotListener(instance);

        return container.getBukkitView();
    }

    <code>
    public static EntityPlayerHandle fromBukkit(org.bukkit.entity.Player player) {
        return createHandle(com.bergerkiller.bukkit.common.conversion.type.HandleConversion.toEntityHandle(player));
    }
    </code>
}

class EntityInsentient extends EntityLiving {
    public (EntityHandle) Entity getLeashHolder();

    public (Object) NavigationAbstract getNavigation();

#if version >= 1.14
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_INSENTIENT_FLAGS:b;
#elseif version >= 1.9
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_INSENTIENT_FLAGS:a;
#else
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_INSENTIENT_FLAGS:###;
#endif

    public boolean isSleeping();

    <code>
    public static final Key<Byte> DATA_INSENTIENT_FLAGS = Key.Type.BYTE.createKey(T.DATA_INSENTIENT_FLAGS, 11);
    public static final int DATA_INSENTIENT_FLAG_NOAI = (1 << 0);
    public static final int DATA_INSENTIENT_FLAG_LEFT_HANDED = (1 << 1);
    </code>
}

class EntityItem extends Entity {
#if version >= 1.14
    public static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:ITEM;
#elseif version >= 1.13
    public static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:b;
#elseif version >= 1.11
    public static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:c;
#elseif version >= 1.9
    public static optional final (DataWatcher.Key<Object>) DataWatcherObject<com.google.common.base.Optional<ItemStack>> DATA_ITEM:c;
#else
    public static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:###;
#endif

    <code>
    public static final Key<org.bukkit.inventory.ItemStack> DATA_ITEM = Key.Type.ITEMSTACK.createKey(T.DATA_ITEM, 10);
    </code>

    private int age;
    public int pickupDelay;

    public (EntityItemHandle) EntityItem((WorldHandle) World world, double x, double y, double z, (ItemStackHandle) ItemStack itemstack);

    public (ItemStackHandle) ItemStack getItemStack();

    public void setItemStack((ItemStackHandle) ItemStack itemstack);
}

class EntityHanging extends Entity {
    public (IntVector3) BlockPosition blockPosition;
}

class EntityBoat extends Entity {
#if version >= 1.14
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_WOOD_TYPE:e;
#elseif version >= 1.9
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_WOOD_TYPE:d;
#else
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_WOOD_TYPE:###;
#endif

    <code>
    public static final Key<com.bergerkiller.bukkit.common.wrappers.BoatWoodType> DATA_WOOD_TYPE = Key.Type.BOAT_WOOD_TYPE.createKey(T.DATA_WOOD_TYPE, -1);
    </code>
}

class EntityMinecartAbstract extends Entity {
#if version >= 1.14
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_FACTOR:b;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_DIRECTION:c;
    private static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_SHAKING_DAMAGE:d;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_TYPE:e;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_OFFSET:f;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_BLOCK_VISIBLE:g;
#elseif version >= 1.9
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_FACTOR:a;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_DIRECTION:b;
    private static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_SHAKING_DAMAGE:c;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_TYPE:d;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_OFFSET:e;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_BLOCK_VISIBLE:f;
#else
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_FACTOR:###;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_SHAKING_DIRECTION:###;
    private static optional final (DataWatcher.Key<Float>) DataWatcherObject<Float> DATA_SHAKING_DAMAGE:###;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_TYPE:###;
    private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_BLOCK_OFFSET:###;
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_BLOCK_VISIBLE:###;
#endif

    <code>
    public static final Key<Integer> DATA_SHAKING_FACTOR = Key.Type.INTEGER.createKey(T.DATA_SHAKING_FACTOR, 17);
    public static final Key<Integer> DATA_SHAKING_DIRECTION = Key.Type.INTEGER.createKey(T.DATA_SHAKING_DIRECTION, 18);
    public static final Key<Float> DATA_SHAKING_DAMAGE = Key.Type.FLOAT.createKey(T.DATA_SHAKING_DAMAGE, 19);
    public static final Key<Integer> DATA_BLOCK_TYPE = Key.Type.INTEGER.createKey(T.DATA_BLOCK_TYPE, 20);
    public static final Key<Integer> DATA_BLOCK_OFFSET = Key.Type.INTEGER.createKey(T.DATA_BLOCK_OFFSET, 21);
    public static final Key<Boolean> DATA_BLOCK_VISIBLE = Key.Type.BOOLEAN.createKey(T.DATA_BLOCK_VISIBLE, 22);
    </code>

    public float getDamage();
    public void setDamage(float damage);
    public int getType();
    public void activate:a(int x, int y, int z, boolean active);
}

class EntityMinecartRideable extends EntityMinecartAbstract {

}

class EntityMinecartFurnace extends EntityMinecartAbstract {
#if version >= 1.14
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_SMOKING:d;
#elseif version >= 1.9
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_SMOKING:c;
#else
    private static optional final (DataWatcher.Key<Boolean>) DataWatcherObject<Boolean> DATA_SMOKING:###;
#endif

    <code>
    public static final Key<Boolean> DATA_SMOKING = Key.Type.BOOLEAN.createKey(T.DATA_SMOKING, 16);
    </code>

#if version >= 1.14
    private int fuel:e;
#elseif version >= 1.9
    private int fuel:d;
#else
    private int fuel:c;
#endif

#if version >= 1.14
    public double pushForceX:b;
    public double pushForceZ:c;
#else
    public double pushForceX:a;
    public double pushForceZ:b;
#endif
}

class EntityMinecartHopper extends EntityMinecartAbstract {
#if version >= 1.13
    private int suckingCooldown:e;
#else
    private int suckingCooldown:b;
#endif

#if version >= 1.16
    public boolean suckItems:B();
#elseif version >= 1.14
    public boolean suckItems:C();
#elseif version >= 1.13
    public boolean suckItems:J();
#elseif version >= 1.12
    public boolean suckItems:H();
#elseif version >= 1.9
    public boolean suckItems:I();
#else
    public boolean suckItems:D();
#endif

#if version >= 1.9.4
    public boolean isSuckingEnabled:isEnabled();
    public void setSuckingEnabled:setEnabled(boolean enabled);
#elseif version >= 1.9
    public boolean isSuckingEnabled:C();
    public void setSuckingEnabled:k(boolean enabled);
#else
    public boolean isSuckingEnabled:y();
    public void setSuckingEnabled:i(boolean enabled);
#endif
}

class EntityMinecartTNT extends EntityMinecartAbstract {
#if version >= 1.14
    private int fuse:b;
#else
    private int fuse:a;
#endif

#if version >= 1.15
    protected void explode:h(double damage);
#elseif version >= 1.9
    protected void explode:c(double damage);
#else
    protected void explode:b(double damage);
#endif

#if version >= 1.16
    public void prime:u();
#elseif version >= 1.14
    public void prime:v();
#elseif version >= 1.13
    public void prime:f();
#else
    public void prime:j();
#endif
}

class EntityMinecartCommandBlock extends EntityMinecartAbstract {
#if version >= 1.14
    public static optional final (DataWatcher.Key<String>) DataWatcherObject<String> DATA_COMMAND:COMMAND;
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<IChatBaseComponent> DATA_PREVIOUS_OUTPUT:c;
#elseif version >= 1.9
    // DataWatcherObject constants are available
    #if version >= 1.11
        public static optional final (DataWatcher.Key<String>) DataWatcherObject<String> DATA_COMMAND:COMMAND;
    #else
        public static optional final (DataWatcher.Key<String>) DataWatcherObject<String> DATA_COMMAND:a;
    #endif
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<IChatBaseComponent> DATA_PREVIOUS_OUTPUT:b;
#else
    // Int keys are used on MC 1.8.8
    public static optional final (DataWatcher.Key<String>) DataWatcherObject<String> DATA_COMMAND:###;
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<IChatBaseComponent> DATA_PREVIOUS_OUTPUT:###;
#endif
    <code>
    public static final Key<String> DATA_COMMAND = Key.Type.STRING.createKey(T.DATA_COMMAND, 23);
    public static final Key<com.bergerkiller.bukkit.common.wrappers.ChatText> DATA_PREVIOUS_OUTPUT = Key.Type.CHAT_TEXT.createKey(T.DATA_PREVIOUS_OUTPUT, 24);
    </code>
}

class EntityMinecartMobSpawner extends EntityMinecartAbstract {
#if version >= 1.14
    private final (com.bergerkiller.bukkit.common.wrappers.MobSpawner) MobSpawnerAbstract mobSpawner:b;
#else
    private final (com.bergerkiller.bukkit.common.wrappers.MobSpawner) MobSpawnerAbstract mobSpawner:a;
#endif
}

class EntityItemFrame extends Entity {
#if version >= 1.14
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:ITEM;
#elseif version >= 1.13
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:e;
#elseif version >= 1.11
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:c;
#elseif version >= 1.9
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<com.google.common.base.Optional<ItemStack>> DATA_ITEM:c;
#else
    private static optional final (DataWatcher.Key<Object>) DataWatcherObject<ItemStack> DATA_ITEM:###;
#endif

    <code>
    public static final Key<org.bukkit.inventory.ItemStack> DATA_ITEM = Key.Type.ITEMSTACK.createKey(T.DATA_ITEM, 8);
    </code>

    public boolean getItemIsMap() {
        ItemStack item = instance.getItem();
        return item != null && item.getItem() == Items.FILLED_MAP;
    }

    public java.util.UUID getItemMapDisplayUUID() {
        ItemStack item = instance.getItem();
        if (item == null) {
            return null;
        }
        return (java.util.UUID) com.bergerkiller.generated.net.minecraft.server.ItemStackHandle.T.getMapDisplayUUID.invoke(item);
    }

    public (org.bukkit.inventory.ItemStack) ItemStack getItem();
    public void setItem((org.bukkit.inventory.ItemStack) ItemStack newItemStack);

    public void refreshItem() {
        instance.setItem(instance.getItem());
    }

    public (IntVector3) BlockPosition getBlockPosition();
    public int getRotationOrdinal:getRotation();

#if forge
    public (org.bukkit.block.BlockFace) EnumDirection getFacing:bt();
#else
    public (org.bukkit.block.BlockFace) EnumDirection getFacing:getDirection();
#endif

    <code>
    public static EntityItemFrameHandle fromBukkit(org.bukkit.entity.ItemFrame itemFrame) {
        return createHandle(com.bergerkiller.bukkit.common.conversion.type.HandleConversion.toEntityHandle(itemFrame));
    }
    </code>
}

class EntityArmorStand extends EntityLiving {
#if version >= 1.14
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_ARMORSTAND_FLAGS:b;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_HEAD:c;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_BODY:d;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_LEFT:e;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_RIGHT:f;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_LEFT:g;
  #if version >= 1.16
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_RIGHT:bo;
  #elseif version >= 1.15
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_RIGHT:bp;
  #else
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_RIGHT:bs;
  #endif
#elseif version >= 1.9
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_ARMORSTAND_FLAGS:a;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_HEAD:b;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_BODY:c;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_LEFT:d;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_RIGHT:e;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_LEFT:f;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_RIGHT:g;
#else
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_ARMORSTAND_FLAGS:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_HEAD:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_BODY:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_LEFT:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_ARM_RIGHT:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_LEFT:###;
    public static optional final (DataWatcher.Key<org.bukkit.util.Vector>) DataWatcherObject<Vector3f> DATA_POSE_LEG_RIGHT:###;
#endif

    <code>
    public static final Key<Byte> DATA_ARMORSTAND_FLAGS = Key.Type.BYTE.createKey(T.DATA_ARMORSTAND_FLAGS, 10);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_HEAD = Key.Type.VECTOR.createKey(T.DATA_POSE_HEAD, 11);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_BODY = Key.Type.VECTOR.createKey(T.DATA_POSE_BODY, 12);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_ARM_LEFT = Key.Type.VECTOR.createKey(T.DATA_POSE_ARM_LEFT, 13);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_ARM_RIGHT = Key.Type.VECTOR.createKey(T.DATA_POSE_ARM_RIGHT, 14);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_LEG_LEFT = Key.Type.VECTOR.createKey(T.DATA_POSE_LEG_LEFT, 15);
    public static final Key<org.bukkit.util.Vector> DATA_POSE_LEG_RIGHT = Key.Type.VECTOR.createKey(T.DATA_POSE_LEG_RIGHT, 16);

    public static final int DATA_FLAG_IS_SMALL = (1 << 0);
    public static final int DATA_FLAG_HAS_ARMS = (1 << 2);
    public static final int DATA_FLAG_NO_BASEPLATE = (1 << 3);
    public static final int DATA_FLAG_SET_MARKER = (1 << 4);
    </code>
}

class EntityBat extends EntityInsentient {
#if version >= 1.14
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_BAT_FLAGS:b;
#elseif version >= 1.9
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_BAT_FLAGS:a;
#else
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_BAT_FLAGS:###;
#endif

    <code>
    public static final Key<Byte> DATA_BAT_FLAGS = Key.Type.BYTE.createKey(T.DATA_BAT_FLAGS, 16);
    public static final int DATA_BAT_FLAG_HANGING = (1 << 0);
    </code>
}

// Since MC 1.9
optional class EntityShulker extends EntityInsentient {
#if version >= 1.14
    protected static optional final (DataWatcher.Key<org.bukkit.block.BlockFace>) DataWatcherObject<EnumDirection> DATA_FACE_DIRECTION:b;
    protected static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<java.util.Optional<BlockPosition>> DATA_AP:c;
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_PEEK:d;
#elseif version >= 1.13
    protected static optional final (DataWatcher.Key<org.bukkit.block.BlockFace>) DataWatcherObject<EnumDirection> DATA_FACE_DIRECTION:a;
    protected static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<java.util.Optional<BlockPosition>> DATA_AP:b;
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_PEEK:c;
#else
    protected static optional final (DataWatcher.Key<org.bukkit.block.BlockFace>) DataWatcherObject<EnumDirection> DATA_FACE_DIRECTION:a;
    protected static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<com.google.common.base.Optional<BlockPosition>> DATA_AP:b;
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_PEEK:c;
#endif

#if version >= 1.12
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_COLOR:COLOR;
#elseif version >= 1.11.2
    public static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_COLOR:bw;
#elseif version >= 1.11
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_COLOR:bw;
#else
    // Unavailable < 1.11
    protected static optional final (DataWatcher.Key<Byte>) DataWatcherObject<Byte> DATA_COLOR:###;
#endif

    <code>
    public static final Key<org.bukkit.block.BlockFace> DATA_FACE_DIRECTION = Key.Type.DIRECTION.createKey(T.DATA_FACE_DIRECTION, -1);
    public static final Key<IntVector3> DATA_AP = Key.Type.BLOCK_POSITION.createKey(T.DATA_AP, -1);
    public static final Key<Byte> DATA_PEEK = Key.Type.BYTE.createKey(T.DATA_PEEK, -1);
    public static final Key<Byte> DATA_COLOR = Key.Type.BYTE.createKey(T.DATA_COLOR, -1);
    </code>
}

class EntityEnderCrystal extends Entity {
    #if version >= 1.13
      private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<java.util.Optional<BlockPosition>> DATA_BEAM_TARGET:b;
    #elseif version >= 1.9
      private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<com.google.common.base.Optional<BlockPosition>> DATA_BEAM_TARGET:b;
    #else
      private static optional final (DataWatcher.Key<IntVector3>) DataWatcherObject<java.util.Optional<BlockPosition>> DATA_BEAM_TARGET:###;
    #endif

    <code>
    public static final Key<IntVector3> DATA_BEAM_TARGET = Key.Type.BLOCK_POSITION.createKey(T.DATA_BEAM_TARGET, -1);
    </code>
}

class EntityFishingHook extends Entity {
    #if version >= 1.14
      private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_HOOKED_ENTITY_ID:c;
    #elseif version >= 1.11
      private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_HOOKED_ENTITY_ID:b;
    #elseif version >= 1.9
      private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_HOOKED_ENTITY_ID:c;
    #else
      private static optional final (DataWatcher.Key<Integer>) DataWatcherObject<Integer> DATA_HOOKED_ENTITY_ID:###;
    #endif

    <code>
    public static final Key<java.util.OptionalInt> DATA_HOOKED_ENTITY_ID = Key.Type.ENTITY_ID.createKey(T.DATA_HOOKED_ENTITY_ID, -1);
    </code>
}