package net.minecraft.server;

import com.mojang.authlib.GameProfile;

import com.bergerkiller.bukkit.common.wrappers.ChatText;
import com.bergerkiller.bukkit.common.wrappers.UseAction;
import com.bergerkiller.bukkit.common.wrappers.ChatText;
import com.bergerkiller.bukkit.common.wrappers.HumanHand;
import com.bergerkiller.bukkit.common.resources.DimensionType;
import com.bergerkiller.bukkit.common.wrappers.WindowType;
import com.bergerkiller.bukkit.common.bases.IntVector3;
import com.bergerkiller.bukkit.common.nbt.CommonTagCompound;

import com.bergerkiller.generated.com.mojang.authlib.GameProfileHandle;

import com.bergerkiller.generated.net.minecraft.server.MobEffectListHandle;
import com.bergerkiller.generated.net.minecraft.server.MobEffectHandle;
import com.bergerkiller.generated.net.minecraft.server.SoundCategoryHandle;
import com.bergerkiller.generated.net.minecraft.server.AttributeModifiableHandle;

import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutScoreboardScoreHandle.EnumScoreboardActionHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutScoreboardTeamHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPlayerInfoHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutEntityDestroyHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPlayerInfoHandle.PlayerInfoDataHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPlayerInfoHandle.EnumPlayerInfoActionHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseEntityHandle.EnumEntityUseActionHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutTitleHandle.EnumTitleActionHandle
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutRemoveEntityEffectHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutMapHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutMapChunkHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutMapChunkHandle.ChunkMapHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutAttachEntityHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutEntityEquipmentHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutMountHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutEntityMetadataHandle
import com.bergerkiller.generated.net.minecraft.server.PacketPlayInBlockDigHandle.EnumPlayerDigTypeHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutOpenWindowHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPositionHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPositionHandle.EnumPlayerTeleportFlagsHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutKeepAliveHandle;
import com.bergerkiller.generated.net.minecraft.server.PacketPlayOutUpdateAttributesHandle;

class Packet {
    <code>
    public com.bergerkiller.bukkit.common.protocol.CommonPacket toCommonPacket() {
        return new com.bergerkiller.bukkit.common.protocol.CommonPacket(getRaw(), getPacketType());
    }

    public com.bergerkiller.bukkit.common.protocol.PacketType getPacketType() {
        return com.bergerkiller.bukkit.common.protocol.PacketType.getType(getRaw());
    }
    </code>

    // Protocol translation functions
    <code>
    protected static final int serializeVelocity(double velocity) {
        return (int) (com.bergerkiller.bukkit.common.utils.MathUtil.clamp(velocity, 3.9) * 8000.0);
    }

    protected static final double deserializeVelocity(int protVelocity) {
        return (double) protVelocity / 8000.0;
    }

    protected static final int serializePosition_1_8_8(double position) {
        return com.bergerkiller.bukkit.common.utils.MathUtil.floor(position * 32.0);
    }

    protected static final double deserializePosition_1_8_8(int protPosition) {
        return (double) protPosition / 32.0;
    }

    protected static final int serializePosition_1_10_2(double position) {
        return com.bergerkiller.bukkit.common.utils.MathUtil.floor(position * 4096.0);
    }

    protected static final double deserializePosition_1_10_2(int protPosition) {
        return (double) protPosition / 4096.0;
    }

    protected static final int serializeRotation(float rotation) {
        return com.bergerkiller.bukkit.common.utils.MathUtil.floor(rotation * 256.0f / 360.0f);
    }

    protected static final float deserializeRotation(int protRotation) {
        return (float) protRotation * 360.0f / 256.0f;
    }

    protected final double getProtocolPosition(Template.Field.Byte field_1_8_8, Template.Field.Integer field_1_10_2) {
        if (field_1_10_2.isAvailable()) {
            return deserializePosition_1_10_2(field_1_10_2.getInteger(getRaw()));
        } else {
            return deserializePosition_1_8_8((int) field_1_8_8.getByte(getRaw()));
        }
    }

    protected final void setProtocolPosition(Template.Field.Byte field_1_8_8, Template.Field.Integer field_1_10_2, double position) {
        if (field_1_10_2.isAvailable()) {
            field_1_10_2.setInteger(getRaw(), serializePosition_1_10_2(position));
        } else {
            field_1_8_8.setByte(getRaw(), (byte) serializePosition_1_8_8(position));
        }
    }

    protected final double getProtocolPosition(Template.Field.Integer field_1_8_8, Template.Field.Double field_1_10_2) {
        if (field_1_10_2.isAvailable()) {
            return field_1_10_2.getDouble(getRaw());
        } else {
            return deserializePosition_1_8_8(field_1_8_8.getInteger(getRaw()));
        }
    }

    protected final void setProtocolPosition(Template.Field.Integer field_1_8_8, Template.Field.Double field_1_10_2, double position) {
        if (field_1_10_2.isAvailable()) {
            field_1_10_2.setDouble(getRaw(), position);
        } else {
            field_1_8_8.setInteger(getRaw(), serializePosition_1_8_8(position));
        }
    }

    protected final float getProtocolRotation(Template.Field.Byte field) {
        return deserializeRotation((int) field.getByte(getRaw()));
    }

    protected final void setProtocolRotation(Template.Field.Byte field, float rotation) {
        field.setByte(getRaw(), (byte) serializeRotation(rotation));
    }

    protected final com.bergerkiller.bukkit.common.wrappers.HumanHand internalGetHand(Template.Field.Converted<Object> field, org.bukkit.entity.HumanEntity humanEntity) {
        if (field.isAvailable()) {
            return com.bergerkiller.bukkit.common.wrappers.HumanHand.fromNMSEnumHand(humanEntity, field.get(getRaw()));
        } else {
            return com.bergerkiller.bukkit.common.wrappers.HumanHand.RIGHT;
        }
    }

    protected final void internalSetHand(Template.Field.Converted<Object> field, org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
        if (field.isAvailable()) {
            field.set(getRaw(), com.bergerkiller.bukkit.common.wrappers.HumanHand.toNMSEnumHand(humanEntity, hand));
        }
    }
    </code>
}

class PacketPlayOutPlayerInfo extends Packet {
    private (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction action:a;
    private final (List<PlayerInfoDataHandle>) List<PacketPlayOutPlayerInfo.PlayerInfoData> players:b;

    public (PacketPlayOutPlayerInfoHandle) PacketPlayOutPlayerInfo();

    class PacketPlayOutPlayerInfo.PlayerInfoData {
        public (PlayerInfoDataHandle) PacketPlayOutPlayerInfo.PlayerInfoData((PacketPlayOutPlayerInfoHandle) PacketPlayOutPlayerInfo packet, (GameProfileHandle) GameProfile profile, int ping, (org.bukkit.GameMode) EnumGamemode gameMode, (ChatText) IChatBaseComponent listName);

        public (GameProfileHandle) GameProfile getProfile:a();
        public int getPing:b();
        public (org.bukkit.GameMode) EnumGamemode getGameMode:c();
        public (ChatText) IChatBaseComponent getListName:d();
    }

    class PacketPlayOutPlayerInfo.EnumPlayerInfoAction {
        enum (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction ADD_PLAYER;
        enum (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction UPDATE_GAME_MODE;
        enum (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction UPDATE_LATENCY;
        enum (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction UPDATE_DISPLAY_NAME;
        enum (EnumPlayerInfoActionHandle) PacketPlayOutPlayerInfo.EnumPlayerInfoAction REMOVE_PLAYER;    
    }
}

class PacketPlayOutEntityDestroy extends Packet {
    private int[] entityIds:a;

    public (PacketPlayOutEntityDestroyHandle) PacketPlayOutEntityDestroy(int[] entityIds);
}

class PacketPlayInKeepAlive extends Packet {
#if version >= 1.12.2
    #require net.minecraft.server.PacketPlayInKeepAlive private long key:a;
    public long getKey() {
        return instance#key;
    }
    public void setKey(long key) {
        instance#key = key;
    }
#else
    #require net.minecraft.server.PacketPlayInKeepAlive private int key:a;
    public long getKey() {
        return (long) instance#key;
    }
    public void setKey(long key) {
        instance#key = (int)key;
    }
#endif
}

class PacketPlayOutKeepAlive extends Packet {
#if version >= 1.12.2
    #require net.minecraft.server.PacketPlayInKeepAlive private long key:a;
    public long getKey() {
        return instance#key;
    }
    public void setKey(long key) {
        instance#key = key;
    }
#else
    #require net.minecraft.server.PacketPlayInKeepAlive private int key:a;
    public long getKey() {
        return (long) instance#key;
    }
    public void setKey(long key) {
        instance#key = (int)key;
    }
#endif

    public static (PacketPlayOutKeepAliveHandle) PacketPlayOutKeepAlive createNew(long key) {
#if version >= 1.12.2
        return new PacketPlayOutKeepAlive(key);
#else
        return new PacketPlayOutKeepAlive((int) key);
#endif
    }
}

class PacketPlayOutScoreboardScore extends Packet {
    class PacketPlayOutScoreboardScore.EnumScoreboardAction {
        enum (EnumScoreboardActionHandle) PacketPlayOutScoreboardScore.EnumScoreboardAction CHANGE;
        enum (EnumScoreboardActionHandle) PacketPlayOutScoreboardScore.EnumScoreboardAction REMOVE;
    }
}

class PacketPlayInUseEntity extends Packet {
    private int usedEntityId:a;
    private (UseAction) PacketPlayInUseEntity.EnumEntityUseAction action;
    private (org.bukkit.util.Vector) Vec3D offset:c;
#if version >= 1.9
    private optional (Object) EnumHand enumHand:d;
#else
    private optional (Object) EnumHand enumHand:###;
#endif
#if version >= 1.16
    private optional boolean sneaking:e;
#else
    private optional boolean sneaking:###;
#endif

    <code>
    public com.bergerkiller.bukkit.common.wrappers.HumanHand getHand(org.bukkit.entity.HumanEntity humanEntity) {
        return internalGetHand(T.enumHand, humanEntity);
    }

    public void setHand(org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
        internalSetHand(T.enumHand, humanEntity, hand);
    }

    public boolean isSneaking() {
        return T.sneaking.isAvailable() && T.sneaking.getBoolean(getRaw());
    }

    public void setSneaking(boolean sneaking) {
        if (T.sneaking.isAvailable()) {
            T.sneaking.setBoolean(getRaw(), sneaking);
        }
    }
    </code>

    class PacketPlayInUseEntity.EnumEntityUseAction {
        enum (EnumEntityUseActionHandle) PacketPlayInUseEntity.EnumEntityUseAction INTERACT;
        enum (EnumEntityUseActionHandle) PacketPlayInUseEntity.EnumEntityUseAction ATTACK;
        enum (EnumEntityUseActionHandle) PacketPlayInUseEntity.EnumEntityUseAction INTERACT_AT;
    }
}

class PacketPlayInBlockPlace extends Packet {
#if version >= 1.9
    private optional (Object) EnumHand enumHand:a;
#else
    private optional (Object) EnumHand enumHand:###;
#endif

    // Spigot only
    public optional long timestamp;

    <code>
    @Override
    public com.bergerkiller.bukkit.common.protocol.PacketType getPacketType() {
        return com.bergerkiller.bukkit.common.protocol.PacketType.IN_BLOCK_PLACE;
    }

    public void setTimestamp(long timestamp) {
        if (T.timestamp.isAvailable()) {
            T.timestamp.setLong(getRaw(), timestamp);
        }
    }

    public com.bergerkiller.bukkit.common.wrappers.HumanHand getHand(org.bukkit.entity.HumanEntity humanEntity) {
        return internalGetHand(T.enumHand, humanEntity);
    }

    public void setHand(org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
        internalSetHand(T.enumHand, humanEntity, hand);
    }
    </code>
}

// PacketPlayInBlockPlace on MC 1.8.8 and before when int direction == 255
class PacketPlayInUseItem extends Packet {
    // Hand since 1.9
#if version >= 1.9
  #if version >= 1.14
    #require net.minecraft.server.PacketPlayInUseItem private EnumHand enumHand:b;
  #else
    #require net.minecraft.server.PacketPlayInUseItem private EnumHand enumHand:c;
  #endif
    public com.bergerkiller.bukkit.common.wrappers.HumanHand getHand(org.bukkit.entity.HumanEntity humanEntity) {
        return com.bergerkiller.bukkit.common.wrappers.HumanHand.fromNMSEnumHand(humanEntity, instance#enumHand);
    }

    public void setHand(org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
        instance#enumHand = (EnumHand) hand.toNMSEnumHand(humanEntity);
    }
#else
    public com.bergerkiller.bukkit.common.wrappers.HumanHand getHand(org.bukkit.entity.HumanEntity humanEntity) {
        return com.bergerkiller.bukkit.common.wrappers.HumanHand.RIGHT;
    }

    public void setHand(org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
    }
#endif

    // Direction
#if version >= 1.14
    #require net.minecraft.server.MovingObjectPositionBlock private final EnumDirection direction_face:b;
    public (org.bukkit.block.BlockFace) EnumDirection getDirection() {
        if (instance.c() == null) return null;
        return instance.c().getDirection();
    }
    public void setDirection((org.bukkit.block.BlockFace) EnumDirection direction) {
        com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseItemHandle.T.initMovingObject.invoke(instance);
        instance.c()#direction_face = direction;
    }
#elseif version >= 1.9
    #require net.minecraft.server.PacketPlayInUseItem private EnumDirection direction_face:b;
    public (org.bukkit.block.BlockFace) EnumDirection getDirection() {
        return instance#direction_face;
    }
    public void setDirection((org.bukkit.block.BlockFace) EnumDirection direction) {
        instance#direction_face = direction;
    }
#else
    #require net.minecraft.server.PacketPlayInUseItem private int direction_index:c;
    public (org.bukkit.block.BlockFace) EnumDirection getDirection() {
        int index = instance#direction_index;
        return EnumDirection.fromType1(index);
    }
    public void setDirection((org.bukkit.block.BlockFace) EnumDirection direction) {
        instance#direction_index = direction.a();
    }
#endif

    // Direction index value of 255 was used for the 'block place' packet on 1.8.8 and before
#if version >= 1.9
    public boolean isBlockPlacePacket() {
        return false;
    }
    public void setBlockPlacePacket() {
    }
#else
    public boolean isBlockPlacePacket() {
        int index = instance#direction_index;
        return index == 255;
    }
    public void setBlockPlacePacket() {
        instance#direction_index = 255;
    }
#endif

#if version >= 1.14
    #require net.minecraft.server.MovingObjectPosition protected final Vec3D position:pos;
    #require net.minecraft.server.MovingObjectPositionBlock private final BlockPosition blockPosition:c;
    public (IntVector3) BlockPosition getPosition() {
        if (instance.c() == null) return null;
        return instance.c().getBlockPosition();
    }
    public void setPosition((IntVector3) BlockPosition blockPosition) {
        com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseItemHandle.T.initMovingObject.invoke(instance);

        // Make sure to preserve deltas
        Vec3D position = instance.c().getPos();
        double new_x = position.x - instance.c().getBlockPosition().getX() + blockPosition.getX();
        double new_y = position.y - instance.c().getBlockPosition().getY() + blockPosition.getY();
        double new_z = position.z - instance.c().getBlockPosition().getZ() + blockPosition.getZ();
        Vec3D new_pos = new Vec3D(new_x, new_y, new_z);
        instance.c()#position = new_pos;
        instance.c()#blockPosition = blockPosition;
    }
    public float getDeltaX() {
        if (instance.c() == null) return 0.0f;
        return (float) (instance.c().getPos().x - (double) instance.c().getBlockPosition().getX());
    }
    public float getDeltaY() {
        if (instance.c() == null) return 0.0f;
        return (float) (instance.c().getPos().y - (double) instance.c().getBlockPosition().getY());
    }
    public float getDeltaZ() {
        if (instance.c() == null) return 0.0f;
        return (float) (instance.c().getPos().z - (double) instance.c().getBlockPosition().getZ());
    }
    public void setDeltaX(float dx) {
        com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseItemHandle.T.initMovingObject.invoke(instance);
        Vec3D old_position = instance.c().getPos();
        Vec3D new_position = new Vec3D((double) dx + instance.c().getBlockPosition().getX(), old_position.y, old_position.z);
        instance.c()#position = new_position;
    }
    public void setDeltaY(float dy) {
        com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseItemHandle.T.initMovingObject.invoke(instance);
        Vec3D old_position = instance.c().getPos();
        Vec3D new_position = new Vec3D(old_position.x, (double) dy + instance.c().getBlockPosition().getY(), old_position.z);
        instance.c()#position = new_position;
    }
    public void setDeltaZ(float dz) {
        com.bergerkiller.generated.net.minecraft.server.PacketPlayInUseItemHandle.T.initMovingObject.invoke(instance);
        Vec3D old_position = instance.c().getPos();
        Vec3D new_position = new Vec3D(old_position.x, old_position.y, (double) dz + instance.c().getBlockPosition().getZ());
        instance.c()#position = new_position;
    }
    public optional void initMovingObject() {
        if (instance.c() != null) {
            return;
        }

        #require net.minecraft.server.PacketPlayInUseItem private MovingObjectPositionBlock movingObject:a;

  #if version >= 1.16.3
        Vec3D origin = Vec3D.ORIGIN;
  #else
        Vec3D origin = Vec3D.a;
  #endif

        MovingObjectPositionBlock moving = MovingObjectPositionBlock.a(origin, EnumDirection.DOWN, BlockPosition.ZERO);
        instance#movingObject = moving; 
    }
#else
  #if version >= 1.9
    #require net.minecraft.server.PacketPlayInUseItem private BlockPosition position:a;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaX:d;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaY:e;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaZ:f;
  #else
    #require net.minecraft.server.PacketPlayInUseItem private BlockPosition position:b;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaX:e;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaY:f;
    #require net.minecraft.server.PacketPlayInUseItem private float deltaZ:g;
  #endif
    public (IntVector3) BlockPosition getPosition() {
        return instance#position;
    }
    public void setPosition((IntVector3) BlockPosition position) {
        instance#position = position;
    }
    public float getDeltaX() {
        return instance#deltaX;
    }
    public float getDeltaY() {
        return instance#deltaY;
    }
    public float getDeltaZ() {
        return instance#deltaZ;
    }
    public void setDeltaX(float dx) {
        return instance#deltaX = dx;
    }
    public void setDeltaY(float dy) {
        return instance#deltaY = dy;
    }
    public void setDeltaZ(float dz) {
        return instance#deltaZ = dz;
    }
    public optional void initMovingObject:###();
#endif

    // Spigot
    public optional long timestamp;

    <code>
    @Override
    public com.bergerkiller.bukkit.common.protocol.PacketType getPacketType() {
        return com.bergerkiller.bukkit.common.protocol.PacketType.IN_USE_ITEM;
    }

    public void setTimestamp(long timestamp) {
        if (T.timestamp.isAvailable()) {
            T.timestamp.setLong(getRaw(), timestamp);
        }
    }
    </code>
}

class PacketPlayInBlockDig extends Packet {
    private (IntVector3) BlockPosition position:a;
    private (org.bukkit.block.BlockFace) EnumDirection direction:b;
    private (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType digType:c;

    class PacketPlayInBlockDig.EnumPlayerDigType {
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType START_DESTROY_BLOCK;
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType ABORT_DESTROY_BLOCK;
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType STOP_DESTROY_BLOCK;
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType DROP_ALL_ITEMS;
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType DROP_ITEM;
        enum (EnumPlayerDigTypeHandle) PacketPlayInBlockDig.EnumPlayerDigType RELEASE_USE_ITEM;
    }
}

class PacketPlayOutTitle extends Packet {
    class PacketPlayOutTitle.EnumTitleAction {
        enum (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction TITLE;
        enum (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction SUBTITLE;
        enum optional (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction ACTIONBAR;
        enum (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction TIMES;
        enum (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction CLEAR;
        enum (EnumTitleActionHandle) PacketPlayOutTitle.EnumTitleAction RESET;
    }
}

class PacketPlayOutChat extends Packet {
    private (ChatText) IChatBaseComponent text:a;

    // Spigot only
    public optional (Object[]) net.md_5.bungee.api.chat.BaseComponent[] components;

#if version >= 1.12
    private (com.bergerkiller.bukkit.common.wrappers.ChatMessageType) ChatMessageType type:b;
#else
    private (com.bergerkiller.bukkit.common.wrappers.ChatMessageType) byte type:b;
#endif
}

class PacketPlayOutCollect extends Packet {
    private int collectedItemId:a;
    private int collectorEntityId:b;

    // since 1.11.2
    private optional int unknown:c;
}

class PacketPlayOutSetSlot extends Packet {
    private int windowId:a;
    private int slot:b;
    private (org.bukkit.inventory.ItemStack) ItemStack item:c;
}

class PacketPlayOutWindowItems extends Packet {
    private int windowId:a;

#if version >= 1.11
    private (List<org.bukkit.inventory.ItemStack>) List<ItemStack> items:b;
#else
    private (List<org.bukkit.inventory.ItemStack>) ItemStack[] items:b;
#endif
}

class PacketPlayOutOpenWindow extends Packet {
    private int windowId:a;
    private (ChatText) IChatBaseComponent windowTitle:c;

    public (PacketPlayOutOpenWindowHandle) PacketPlayOutOpenWindow();

#if version >= 1.14
    #require net.minecraft.server.PacketPlayOutOpenWindow private int windowTypeId:b;

    public WindowType getWindowType() {
        return com.bergerkiller.bukkit.common.wrappers.WindowType.fromWindowTypeId(instance#windowTypeId);
    }

    public void setWindowType(WindowType windowType) {
        int id = windowType.getTypeId();
        if (id == -1) {
            throw new IllegalArgumentException("Window type " + windowType.name() + " is not supported");
        }
        instance#windowTypeId = id;
    }
#else
    #require net.minecraft.server.PacketPlayOutOpenWindow private String windowName:b;
    #require net.minecraft.server.PacketPlayOutOpenWindow private int slotCount:d;

    public WindowType getWindowType() {
        String name = instance#windowName;
        int slotCount = instance#slotCount;
        return com.bergerkiller.bukkit.common.wrappers.WindowType.fromLegacyName_1_8(name, slotCount);
    }

    public void setWindowType(WindowType windowType) {
        String legacyName = windowType.getLegacyName_1_8();
        if (legacyName == null) {
            throw new IllegalArgumentException("Window type " + windowType.name() + " is not supported");
        }
        instance#windowName = legacyName;
        instance#slotCount = windowType.getInventorySlots();
    }
#endif
}

class PacketPlayInArmAnimation extends Packet {
#if version >= 1.9
    private optional (Object) EnumHand enumHand:a;
#else
    private optional (Object) EnumHand enumHand:###;
#endif

    <code>
    public com.bergerkiller.bukkit.common.wrappers.HumanHand getHand(org.bukkit.entity.HumanEntity humanEntity) {
        return internalGetHand(T.enumHand, humanEntity);
    }

    public void setHand(org.bukkit.entity.HumanEntity humanEntity, com.bergerkiller.bukkit.common.wrappers.HumanHand hand) {
        internalSetHand(T.enumHand, humanEntity, hand);
    }
    </code>
}

class PacketPlayOutRemoveEntityEffect extends Packet {
    private int entityId:a;
#if version >= 1.9
    private (MobEffectListHandle) MobEffectList effectList:b;
#else
    private (MobEffectListHandle) int effectList:b;
#endif

    public (PacketPlayOutRemoveEntityEffectHandle) PacketPlayOutRemoveEntityEffect();

    <code>
    public static PacketPlayOutRemoveEntityEffectHandle createNew(int entityId, MobEffectListHandle mobEffectList) {
        PacketPlayOutRemoveEntityEffectHandle handle = createNew();
        handle.setEntityId(entityId);
        handle.setEffectList(mobEffectList);
        return handle;
    }
    </code>
}

class PacketPlayOutLogin extends Packet {
    private int playerId:a;

#if version >= 1.15
    private unknown long encryptedWorldSeed:b;
    private boolean hardcore:c;
    private (org.bukkit.GameMode) EnumGamemode gameMode:d;
#else
    private boolean hardcore:b;
    private (org.bukkit.GameMode) EnumGamemode gameMode:c;
#endif

    // Since 1.16 the previous game mode of the player is also sent
    // This allows the player to toggle back and forth between modes
#if version >= 1.16
    #require net.minecraft.server.PacketPlayOutLogin private EnumGamemode previousGameMode:e;

    public (org.bukkit.GameMode) EnumGamemode getPreviousGameMode() {
        EnumGamemode mode = instance#previousGameMode;
        if (mode == EnumGamemode.NOT_SET) {
            return null;
        } else {
            return mode;
        }
    }

    public void setPreviousGameMode((org.bukkit.GameMode) EnumGamemode gameMode) {
        if (gameMode == null) {
            gameMode = EnumGamemode.NOT_SET;
        }
        instance#previousGameMode = gameMode;
    }
#else
    public (org.bukkit.GameMode) EnumGamemode getPreviousGameMode() {
        return null;
    }

    public void setPreviousGameMode((org.bukkit.GameMode) EnumGamemode gameMode) {
    }
#endif

#if version >= 1.16.2
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) DimensionManager dimensionType:h;
#elseif version >= 1.16
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) ResourceKey<DimensionManager> dimensionType:h;
#elseif version >= 1.15
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) DimensionManager dimensionType:e;
#elseif version >= 1.13.1
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) DimensionManager dimensionType:d;
#else
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) int dimensionType:d;
#endif

    // Difficulty field only exists <= 1.13.2
#if version >= 1.14
    private optional (org.bukkit.Difficulty) EnumDifficulty difficulty:###;
#else
    private optional (org.bukkit.Difficulty) EnumDifficulty difficulty:e;
#endif

    // View distance field only exists >= 1.14
#if version >= 1.16
    private int maxPlayers:j;

    private optional int viewDistance:k;
#elseif version >= 1.15
    private int maxPlayers:f;
    //TODO: Removed on 1.16. Keep this?
    // private (org.bukkit.WorldType) WorldType worldType:g;
    private optional int viewDistance:h;
#elseif version >= 1.14
    private int maxPlayers:e;
    //TODO: Removed on 1.16. Keep this?
    // private (org.bukkit.WorldType) WorldType worldType:f;
    private optional int viewDistance:g;
#else
    private int maxPlayers:f;
    //TODO: Removed on 1.16. Keep this?
    // private (org.bukkit.WorldType) WorldType worldType:g;
    private optional int viewDistance:###;
#endif

#if version >= 1.16
    private boolean reducedDebugInfo:l;
    private unknown boolean noImmediateRespawn:m;
    private unknown boolean isDebugWorld:n;
    private unknown boolean isFlatWorld:o;
#elseif version >= 1.15
    private boolean reducedDebugInfo:i;
    private unknown boolean noImmediateRespawn:j;
#else
    private boolean reducedDebugInfo:h;
#endif

    // Encrypted world seed field was added on MC 1.15
    // It has little meaning, so we just add a method to initialize it
    public void setEncryptedWorldSeed((org.bukkit.World) WorldServer world) {
#if version >= 1.16
        #require net.minecraft.server.PacketPlayOutLogin private long encryptedWorldSeed:b;
        instance#encryptedWorldSeed = BiomeManager.a(world.getSeed());
#elseif version >= 1.15
        #require net.minecraft.server.PacketPlayOutLogin private long encryptedWorldSeed:b;
        instance#encryptedWorldSeed = WorldData.c(world.getWorldData().getSeed());
#endif
    }
}

class PacketPlayOutRespawn extends Packet {
#if version >= 1.16.2
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) DimensionManager dimensionType:a;
#elseif version >= 1.16
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) ResourceKey<DimensionManager> dimensionType:a;
#elseif version >= 1.13.1
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) DimensionManager dimensionType:a;
#else
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<DimensionType>) int dimensionType:a;
#endif

    // Since Minecraft 1.16: World environment has a resource key, too!
#if version >= 1.16
    #require net.minecraft.server.PacketPlayOutRespawn private ResourceKey<World> worldName:b;

    public (com.bergerkiller.bukkit.common.resources.ResourceKey<org.bukkit.World>) ResourceKey<World> getWorldName() {
        return instance#worldName;
    }
    
    public void setWorldName((com.bergerkiller.bukkit.common.resources.ResourceKey<org.bukkit.World>) ResourceKey<World> worldType) {
        instance#worldName = worldType;
    }
#else
    public (com.bergerkiller.bukkit.common.resources.ResourceKey<org.bukkit.World>) ResourceKey<World> getWorldName() {
        return null;
    }

    public void setWorldName((com.bergerkiller.bukkit.common.resources.ResourceKey<org.bukkit.World>) ResourceKey<World> worldType) {
    }
#endif

    // Dimension and WorldType are now resource keys
    // private ResourceKey<World> b;

    // Difficulty field only exists <= 1.13.2
#if version >= 1.14
    private optional (org.bukkit.Difficulty) EnumDifficulty difficulty:###;
#else
    private optional (org.bukkit.Difficulty) EnumDifficulty difficulty:b;
#endif

#if version >= 1.16
    //TODO: private ResourceKey<World> b;

    private unknown long encryptedWorldSeed:c;
    private (org.bukkit.GameMode) EnumGamemode gamemode:d;

    private unknown boolean isDebugWorld:f;
    private unknown boolean isFlatWorld:g;
    private unknown boolean unknownAlwaysTrue:h;
#elseif version >= 1.15
    private unknown long encryptedWorldSeed:b;
    private (org.bukkit.GameMode) EnumGamemode gamemode:c;

    //TODO: Was removed on 1.16, do anything with this?
    // private (org.bukkit.WorldType) WorldType worldType:d;
#elseif version >= 1.14
    private (org.bukkit.GameMode) EnumGamemode gamemode:b;

    //TODO: Was removed on 1.16, do anything with this?
    // private (org.bukkit.WorldType) WorldType worldType:c;
#else
    private (org.bukkit.GameMode) EnumGamemode gamemode:c;

    //TODO: Was removed on 1.16, do anything with this?
    // private (org.bukkit.WorldType) WorldType worldType:d;
#endif

    // Since 1.16 the previous game mode of the player is also sent
    // This allows the player to toggle back and forth between modes
#if version >= 1.16
    #require net.minecraft.server.PacketPlayOutRespawn private EnumGamemode previousGameMode:e;

    public (org.bukkit.GameMode) EnumGamemode getPreviousGameMode() {
        EnumGamemode mode = instance#previousGameMode;
        if (mode == EnumGamemode.NOT_SET) {
            return null;
        } else {
            return mode;
        }
    }

    public void setPreviousGameMode((org.bukkit.GameMode) EnumGamemode gameMode) {
        if (gameMode == null) {
            gameMode = EnumGamemode.NOT_SET;
        }
        instance#previousGameMode = gameMode;
    }
#else
    public (org.bukkit.GameMode) EnumGamemode getPreviousGameMode() {
        return null;
    }

    public void setPreviousGameMode((org.bukkit.GameMode) EnumGamemode gameMode) {
    }
#endif

    // Encrypted world seed field was added on MC 1.15
    // It has little meaning, so we just add a method to initialize it
    public void setEncryptedWorldSeed((org.bukkit.World) WorldServer world) {
#if version >= 1.16
        #require net.minecraft.server.PacketPlayOutRespawn private long encryptedWorldSeed:c;
        instance#encryptedWorldSeed = BiomeManager.a(world.getSeed());
#elseif version >= 1.15
        #require net.minecraft.server.PacketPlayOutRespawn private long encryptedWorldSeed:b;
        instance#encryptedWorldSeed = WorldData.c(world.getWorldData().getSeed());
#endif
    }
}

class PacketPlayOutPlayerListHeaderFooter extends Packet {
#if version >= 1.13.1
    private (ChatText) IChatBaseComponent header:header;
    private (ChatText) IChatBaseComponent footer:footer;
#else
    private (ChatText) IChatBaseComponent header:a;
    private (ChatText) IChatBaseComponent footer:b;
#endif
}

class PacketPlayOutMap extends Packet {
    private int itemId:a;
    private byte scale:b;

#if version >= 1.14
    private optional boolean track:c;
    private optional boolean locked:d;
    private (org.bukkit.map.MapCursor[]) MapIcon[] cursors:e;
    private int xmin:f;
    private int ymin:g;
    private int width:h;
    private int height:i;
    private byte[] pixels:j;
#elseif version >= 1.9
    private optional boolean track:c;
    private optional boolean locked:###;
    private (org.bukkit.map.MapCursor[]) MapIcon[] cursors:d;
    private int xmin:e;
    private int ymin:f;
    private int width:g;
    private int height:h;
    private byte[] pixels:i;
#else
    private optional boolean track:###;
    private optional boolean locked:###;
    private (org.bukkit.map.MapCursor[]) MapIcon[] cursors:c;
    private int xmin:d;
    private int ymin:e;
    private int width:f;
    private int height:g;
    private byte[] pixels:h;
#endif

    public (PacketPlayOutMapHandle) PacketPlayOutMap();

#if version >= 1.14
    #require net.minecraft.server.PacketPlayOutMap private boolean locked:d;

    public boolean isLocked() {
        return instance#locked;
    }

    public void setLocked(boolean locked) {
        instance#locked = locked;
    }
#else
    public boolean isLocked() {
        return false;
    }

    public void setLocked(boolean locked) {
    }
#endif

#if version >= 1.9
    #require net.minecraft.server.PacketPlayOutMap private boolean track:c;

    public boolean isTrack() {
        return instance#track;
    }

    public void setTrack(boolean track) {
        instance#track = track;
    }
#else
    public boolean isTrack() {
        return false;
    }

    public void setTrack(boolean track) {
    }
#endif
}

class PacketPlayOutMapChunk extends Packet {
    private int x:a;
    private int z:b;

#if version >= 1.15
    private optional int sectionsMask:c;
    private optional (CommonTagCompound) NBTTagCompound metadata:d;
  #if version >= 1.16.2
    private unknown int[] biomeStorage:e;
  #else
    private unknown BiomeStorage biomeStorage:e;
  #endif
    private optional byte[] data:f;
    private optional (List<CommonTagCompound>) List<NBTTagCompound> tags:g;
    private optional (PacketPlayOutMapChunkHandle.ChunkMapHandle) PacketPlayOutMapChunk.ChunkMap chunkInfo:###;
    private boolean hasBiomeData:h;
#elseif version >= 1.14
    private optional int sectionsMask:c;
    private optional (CommonTagCompound) NBTTagCompound metadata:d;
    private optional byte[] data:e;
    private optional (List<CommonTagCompound>) List<NBTTagCompound> tags:f;
    private optional (PacketPlayOutMapChunkHandle.ChunkMapHandle) PacketPlayOutMapChunk.ChunkMap chunkInfo:###;
    private boolean hasBiomeData:g;
#elseif version >= 1.9.4
    private optional int sectionsMask:c;
    private optional (CommonTagCompound) NBTTagCompound metadata:###;
    private optional byte[] data:d;
    private optional (List<CommonTagCompound>) List<NBTTagCompound> tags:e;
    private optional (PacketPlayOutMapChunkHandle.ChunkMapHandle) PacketPlayOutMapChunk.ChunkMap chunkInfo:###;
    private boolean hasBiomeData:f;
#elseif version >= 1.9
    private optional int sectionsMask:c;
    private optional (CommonTagCompound) NBTTagCompound metadata:###;
    private optional byte[] data:d;
    private optional (List<CommonTagCompound>) List<NBTTagCompound> tags:###;
    private optional (PacketPlayOutMapChunkHandle.ChunkMapHandle) PacketPlayOutMapChunk.ChunkMap chunkInfo:###;
    private boolean hasBiomeData:e;
#else
    private optional int sectionsMask:###;
    private optional (CommonTagCompound) NBTTagCompound metadata:###;
    private optional byte[] data:###;
    private optional (List<CommonTagCompound>) List<NBTTagCompound> tags:###;
    private optional (PacketPlayOutMapChunkHandle.ChunkMapHandle) PacketPlayOutMapChunk.ChunkMap chunkInfo:c;
    private boolean hasBiomeData:d;
#endif

    <code>
    public CommonTagCompound getMetadata() {
        if (T.metadata.isAvailable()) {
            return T.metadata.get(getRaw());
        } else {
            return new CommonTagCompound();
        }
    }

    public void setMetadata(CommonTagCompound metadata) {
        if (T.metadata.isAvailable()) {
            T.metadata.set(getRaw(), metadata);
        }
    }

    public int getSectionsMask() {
        if (T.sectionsMask.isAvailable()) {
            return T.sectionsMask.getInteger(getRaw());
        } else {
            return T.chunkInfo.get(getRaw()).getSectionsMask();
        }
    }

    public void setSectionsMask(int sectionsMask) {
        if (T.sectionsMask.isAvailable()) {
            T.sectionsMask.set(getRaw(), sectionsMask);
        } else {
            T.chunkInfo.get(getRaw()).setSectionsMask(sectionsMask);
        }
    }

    public byte[] getData() {
        if (T.data.isAvailable()) {
            return T.data.get(getRaw());
        } else {
            return T.chunkInfo.get(getRaw()).getData();
        }
    }
    
    public void setData(byte[] data) {
        if (T.data.isAvailable()) {
            T.data.set(getRaw(), data);
        } else {
            T.chunkInfo.get(getRaw()).setData(data);
        }
    }

    public List<CommonTagCompound> getTags() {
        if (T.tags.isAvailable()) {
            return T.tags.get(getRaw());
        } else {
            return java.util.Collections.emptyList();
        }
    }

    public void setTags(List<CommonTagCompound> tags) {
        if (T.tags.isAvailable()) {
            T.tags.set(getRaw(), tags);
        } else {
            // Unsupported. Do nothing.
        }
    }
    </code>

    // MC 1.8.8 only
    optional class PacketPlayOutMapChunk.ChunkMap {
        public byte[] data:a;
        public int sectionsMask:b;
    }
}

// Only >= MC 1.9 (MC 1.8.8 relies on clients themselves to unload as needed, for some reason)
optional class PacketPlayOutUnloadChunk extends Packet {
    private int cx:a;
    private int cz:b;
}

class PacketPlayOutNamedSoundEffect extends Packet {
#if version >= 1.9
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<com.bergerkiller.bukkit.common.resources.SoundEffect>) SoundEffect sound:a;
    private optional (String) SoundCategory category_1_10_2:b;
    private int x:c;
    private int y:d;
    private int z:e;
    private float volume:f;
    private optional int pitch_1_8_8:###;
    private optional float pitch_1_10_2:g;
#else
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<com.bergerkiller.bukkit.common.resources.SoundEffect>) String sound:a;
    private optional (String) SoundCategory category_1_10_2:###;
    private int x:b;
    private int y:c;
    private int z:d;
    private float volume:e;
    private optional int pitch_1_8_8:f;
    private optional float pitch_1_10_2:###;
#endif

    // Accessor functions for pitch
    <code>
    public float getPitch() {
        if (T.pitch_1_10_2.isAvailable()) {
            return T.pitch_1_10_2.getFloat(getRaw());
        } else {
            return (float) T.pitch_1_8_8.getInteger(getRaw()) / 63.0f;
        }
    }

    public void setPitch(float pitch) {
        if (T.pitch_1_10_2.isAvailable()) {
            T.pitch_1_10_2.setFloat(getRaw(), pitch);
        } else {
            T.pitch_1_8_8.setInteger(getRaw(), (int) (pitch * 63.0f));
        }
    }
    </code>

    // Accessor function for sound category (by name)
    // On MC 1.8.8 this does nothing (always returns "master")
    <code>
    public String getCategory() {
        if (T.category_1_10_2.isAvailable()) {
            return T.category_1_10_2.get(getRaw());
        } else {
            return "master";
        }
    }

    public void setCategory(String categoryName) {
        if (T.category_1_10_2.isAvailable()) {
            T.category_1_10_2.set(getRaw(), categoryName);
        } else {
            // Do nothing, unused
        }
    }
    </code>

}

// Since MC 1.9
optional class PacketPlayOutCustomSoundEffect extends Packet {
#if version >= 1.13
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<com.bergerkiller.bukkit.common.resources.SoundEffect>) MinecraftKey sound:a;
#else
    private (com.bergerkiller.bukkit.common.resources.ResourceKey<com.bergerkiller.bukkit.common.resources.SoundEffect>) String sound:a;
#endif
    private (String) SoundCategory category:b;
    private int x:c;
    private int y:d;
    private int z:e;
    private float volume:f;
#if version >= 1.10.2
    private optional float opt_pitch_float:g;
    private optional int opt_pitch_integer:###;
#else
    private optional float opt_pitch_float:###;
    private optional int opt_pitch_integer:g;
#endif

    <code>
    public void setPitch(float pitch) {
        if (T.opt_pitch_float.isAvailable()) {
            T.opt_pitch_float.setFloat(getRaw(), pitch);
        } else {
            T.opt_pitch_integer.setInteger(getRaw(), (int) (pitch * 63.0f));
        }
    }

    public float getPitch() {
        if (T.opt_pitch_float.isAvailable()) {
            return T.opt_pitch_float.getFloat(getRaw());
        } else {
            return (float) T.opt_pitch_integer.getInteger(getRaw()) / 63.0f;
        }
    }
    </code>
}

class PacketPlayOutPosition extends Packet {
    private double x:a;
    private double y:b;
    private double z:c;
    private float yaw:d;
    private float pitch:e;
    private (Set<EnumPlayerTeleportFlagsHandle>) Set<PacketPlayOutPosition.EnumPlayerTeleportFlags> teleportFlags:f;

    // >= MC 1.9
    private optional int teleportWaitTimer:g;

    <code>
    public int getTeleportWaitTimer() {
        if (T.teleportWaitTimer.isAvailable()) {
            return T.teleportWaitTimer.getInteger(getRaw());
        } else {
            return 0;
        }
    }

    public void setTeleportWaitTimer(int ticks) {
        if (T.teleportWaitTimer.isAvailable()) {
            T.teleportWaitTimer.setInteger(getRaw(), ticks);
        }
    }

    public void setRotationRelative(boolean relative) {
        Set<EnumPlayerTeleportFlagsHandle> flags = getTeleportFlags();
        if (relative) {
            flags.add(EnumPlayerTeleportFlagsHandle.Y_ROT);
            flags.add(EnumPlayerTeleportFlagsHandle.X_ROT);
        } else {
            flags.remove(EnumPlayerTeleportFlagsHandle.Y_ROT);
            flags.remove(EnumPlayerTeleportFlagsHandle.X_ROT);
        }
    }

    public void setPositionRelative(boolean relative) {
        Set<EnumPlayerTeleportFlagsHandle> flags = getTeleportFlags();
        if (relative) {
            flags.add(EnumPlayerTeleportFlagsHandle.X);
            flags.add(EnumPlayerTeleportFlagsHandle.Y);
            flags.add(EnumPlayerTeleportFlagsHandle.Z);
        } else {
            flags.remove(EnumPlayerTeleportFlagsHandle.X);
            flags.remove(EnumPlayerTeleportFlagsHandle.Y);
            flags.remove(EnumPlayerTeleportFlagsHandle.Z);
        }
    }
    </code>

    public static (PacketPlayOutPositionHandle) PacketPlayOutPosition createRelative(double dx, double dy, double dz, float dyaw, float dpitch) {
        java.util.Set flags = com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPositionHandle$EnumPlayerTeleportFlagsHandle.allRelative();
#if version >= 1.9
        return new PacketPlayOutPosition(dx, dy, dz, dyaw, dpitch, flags, 0);
#else
        return new PacketPlayOutPosition(dx, dy, dz, dyaw, dpitch, flags);
#endif
    }

    <code>
    public static PacketPlayOutPositionHandle createAbsolute(org.bukkit.Location location) {
        return createAbsolute(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
    }
    </code>

    public static (PacketPlayOutPositionHandle) PacketPlayOutPosition createAbsolute(double x, double y, double z, float yaw, float pitch) {
        java.util.Set flags = com.bergerkiller.generated.net.minecraft.server.PacketPlayOutPositionHandle$EnumPlayerTeleportFlagsHandle.allAbsolute();
#if version >= 1.9
        return new PacketPlayOutPosition(x, y, z, yaw, pitch, flags, 0);
#else
        return new PacketPlayOutPosition(x, y, z, yaw, pitch, flags);
#endif
    }

    class PacketPlayOutPosition.EnumPlayerTeleportFlags {
        enum (EnumPlayerTeleportFlagsHandle) PacketPlayOutPosition.EnumPlayerTeleportFlags X;
        enum (EnumPlayerTeleportFlagsHandle) PacketPlayOutPosition.EnumPlayerTeleportFlags Y;
        enum (EnumPlayerTeleportFlagsHandle) PacketPlayOutPosition.EnumPlayerTeleportFlags Z;
        enum (EnumPlayerTeleportFlagsHandle) PacketPlayOutPosition.EnumPlayerTeleportFlags Y_ROT;
        enum (EnumPlayerTeleportFlagsHandle) PacketPlayOutPosition.EnumPlayerTeleportFlags X_ROT;

        <code>
        public static Set<?> allAbsolute() {
            return java.util.EnumSet.noneOf((Class) T.getType());
        }

        public static Set<?> allRelative() {
            return java.util.EnumSet.allOf((Class) T.getType());
        }
        </code>
    }
}

// Available >= MC 1.9
optional class PacketPlayOutBoss extends Packet {
    private UUID entityUUID:a;
    private (Object) PacketPlayOutBoss.Action action:b;
    private (Object) IChatBaseComponent chat:c;
    private float progress:d;
    private (Object) BossBattle.BarColor bossBarColor:e;
    private (Object) BossBattle.BarStyle bossBarStyle:f;
    private boolean unknown1:g;
    private boolean unknown2:h;
    private boolean unknown3:i;
}

class PacketPlayOutAttachEntity extends Packet {
#if version >= 1.9
    private optional int leashId:###;
    private int passengerId:a;
    private int vehicleId:b;
#else
    private optional int leashId:a;
    private int passengerId:b;
    private int vehicleId:c;
#endif

#if version >= 1.9
    public boolean isLeash() {
        return false;
    }

    public void setIsLeash(boolean isLeash) {
    }

    public static (PacketPlayOutAttachEntityHandle) PacketPlayOutAttachEntity createNewMount((org.bukkit.entity.Entity) Entity passengerEntity, (org.bukkit.entity.Entity) Entity vehicleEntity) {
        throw new UnsupportedOperationException("Not supported >= MC 1.9, use Mount packet instead");
    }

    public static (PacketPlayOutAttachEntityHandle) PacketPlayOutAttachEntity createNewLeash((org.bukkit.entity.Entity) Entity leashedEntity, (org.bukkit.entity.Entity) Entity holderEntity) {
        return new PacketPlayOutAttachEntity(leashedEntity, holderEntity);
    }
#else
    #require net.minecraft.server.PacketPlayOutAttachEntity private int leashId:a;
    public boolean isLeash() {
        int leashId = instance#leashId;
        return leashId == 1;
    }

    public void setIsLeash(boolean isLeash) {
        int id = isLeash ? 1 : 0;
        instance#leashId = id;
    }

    public static (PacketPlayOutAttachEntityHandle) PacketPlayOutAttachEntity createNewMount((org.bukkit.entity.Entity) Entity passengerEntity, (org.bukkit.entity.Entity) Entity vehicleEntity) {
        return new PacketPlayOutAttachEntity(0, passengerEntity, vehicleEntity);
    }

    public static (PacketPlayOutAttachEntityHandle) PacketPlayOutAttachEntity createNewLeash((org.bukkit.entity.Entity) Entity leashedEntity, (org.bukkit.entity.Entity) Entity holderEntity) {
        return new PacketPlayOutAttachEntity(1, leashedEntity, holderEntity);
    }
#endif

    <code>
    public static PacketPlayOutAttachEntityHandle createNewLeash(int leashedEntityId, int holderEntityId) {
        PacketPlayOutAttachEntityHandle packet = T.newHandleNull();
        packet.setVehicleId(holderEntityId);
        packet.setPassengerId(leashedEntityId);
        packet.setIsLeash(true);
        return packet;
    }

    public static PacketPlayOutAttachEntityHandle createNewMount(int passengerEntityId, int vehicleEntityId) {
        if (!T.leashId.isAvailable()) {
            throw new UnsupportedOperationException("Not supported >= MC 1.9, use Mount packet instead");
        }
        PacketPlayOutAttachEntityHandle packet = T.newHandleNull();
        packet.setVehicleId(vehicleEntityId);
        packet.setPassengerId(passengerEntityId);
        packet.setIsLeash(false);
        return packet;
    }
    </code>
}

class PacketPlayOutEntityEquipment extends Packet {
    private int entityId:a;

#if version >= 1.16
    #require net.minecraft.server.PacketPlayOutEntityEquipment private final java.util.List<com.mojang.datafixers.util.Pair<EnumItemSlot, ItemStack>> slots:b;

    // Multiple slots are possible
    public int getSlotCount() {
        java.util.List slots = instance#slots;
        return slots.size();
    }

    public static (PacketPlayOutEntityEquipmentHandle) PacketPlayOutEntityEquipment createNew(int entityId, (org.bukkit.inventory.EquipmentSlot) EnumItemSlot slot, (org.bukkit.inventory.ItemStack) ItemStack itemStack) {
        java.util.List slots = com.google.common.collect.Lists.newArrayList();
        slots.add(com.mojang.datafixers.util.Pair.of(slot, itemStack));
        return new PacketPlayOutEntityEquipment(entityId, slots);
    }

    public (org.bukkit.inventory.EquipmentSlot) EnumItemSlot getEquipmentSlot(int index) {
        java.util.List slots = instance#slots;
        com.mojang.datafixers.util.Pair entry = (com.mojang.datafixers.util.Pair) slots.get(index);
        return (EnumItemSlot) entry.getFirst();
    }

    public void setEquipmentSlot(int index, (org.bukkit.inventory.EquipmentSlot) EnumItemSlot slot) {
        java.util.List slots = instance#slots;
        com.mojang.datafixers.util.Pair entry = (com.mojang.datafixers.util.Pair) slots.get(index);
        slots.set(index, com.mojang.datafixers.util.Pair.of(slot, entry.getSecond()));
    }

    public (org.bukkit.inventory.ItemStack) ItemStack getItemStack(int index) {
        java.util.List slots = instance#slots;
        com.mojang.datafixers.util.Pair entry = (com.mojang.datafixers.util.Pair) slots.get(index);
        return (ItemStack) entry.getSecond();
    }

    public void setItemStack(int index, (org.bukkit.inventory.ItemStack) ItemStack itemStack) {
        java.util.List slots = instance#slots;
        com.mojang.datafixers.util.Pair entry = (com.mojang.datafixers.util.Pair) slots.get(index);
        slots.set(index, com.mojang.datafixers.util.Pair.of(entry.getFirst(), itemStack));
    }
#else
    // Only one slot is possible
    public int getSlotCount() {
        return 1;
    }

  #if version >= 1.9
    public static (PacketPlayOutEntityEquipmentHandle) PacketPlayOutEntityEquipment createNew(int entityId, (org.bukkit.inventory.EquipmentSlot) EnumItemSlot slot, (org.bukkit.inventory.ItemStack) ItemStack itemStack) {
        return new PacketPlayOutEntityEquipment(entityId, slot, itemStack);
    }
  #else
    public static (PacketPlayOutEntityEquipmentHandle) PacketPlayOutEntityEquipment createNew(int entityId, (org.bukkit.inventory.EquipmentSlot) int slot, (org.bukkit.inventory.ItemStack) ItemStack itemStack) {
        return new PacketPlayOutEntityEquipment(entityId, slot, itemStack);
    }
  #endif

  #if version >= 1.9
    #require net.minecraft.server.PacketPlayOutEntityEquipment private EnumItemSlot slot:b;
    public (org.bukkit.inventory.EquipmentSlot) EnumItemSlot getEquipmentSlot(int index) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        return instance#slot;
    }
    public void setEquipmentSlot(int index, (org.bukkit.inventory.EquipmentSlot) EnumItemSlot slot) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        instance#slot = slot;
    }
  #else
    #require net.minecraft.server.PacketPlayOutEntityEquipment private (org.bukkit.inventory.EquipmentSlot) int slot:b;
    public (org.bukkit.inventory.EquipmentSlot) int getEquipmentSlot(int index) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        return instance#slot;
    }
    public void setEquipmentSlot(int index, (org.bukkit.inventory.EquipmentSlot) int slot) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        instance#slot = slot;
    }
  #endif

    #require net.minecraft.server.PacketPlayOutEntityEquipment private ItemStack itemStack:c;
    public (org.bukkit.inventory.ItemStack) ItemStack getItemStack(int index) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        return instance#itemStack;
    }
    public void setItemStack(int slot, (org.bukkit.inventory.ItemStack) ItemStack itemStack) {
        if (index != 0) { throw new IndexOutOfBoundsException("Index out of range: " + index); }
        instance#itemStack = itemStack;
    }
#endif
}

// Only available >= MC 1.9
optional class PacketPlayOutMount extends Packet {
    private int entityId:a;
    private int[] mountedEntityIds:b;

    public (PacketPlayOutMountHandle) PacketPlayOutMount();

    <code>
    public void addMountedEntityId(int entityId) {
        int[] oldIds = this.getMountedEntityIds();
        if (oldIds == null || oldIds.length == 0) {
            this.setMountedEntityIds(new int[] {entityId});
        } else {
            int[] newIds = new int[oldIds.length + 1];
            for (int i = 0; i < oldIds.length; i++) {
                newIds[i] = oldIds[i];
            }
            newIds[newIds.length - 1] = entityId;
            this.setMountedEntityIds(newIds);
        }
    }

    public static PacketPlayOutMountHandle createNew(int entityId, int[] mountedEntityIds) {
        PacketPlayOutMountHandle handle = createNew();
        handle.setEntityId(entityId);
        handle.setMountedEntityIds(mountedEntityIds);
        return handle;
    }
    </code>
}

class PacketPlayOutCombatEvent {
    public (Object) PacketPlayOutCombatEvent.EnumCombatEventType eventType:a;
    public int entityId1:b;
    public int entityId2:c;
    public int tickDuration:d;
#if version >= 1.9
    public (ChatText) IChatBaseComponent message:e;
#else
    public (ChatText) String message:e;
#endif
}

// Only >= MC 1.9
optional class PacketPlayOutSetCooldown extends Packet {
    private (org.bukkit.Material) Item material:a;
    private int cooldown:b;
}

class PacketPlayOutScoreboardTeam extends Packet {
    private String name:a;
#if version >= 1.13
    private (ChatText) IChatBaseComponent displayName:b;
    private (ChatText) IChatBaseComponent prefix:c;
    private (ChatText) IChatBaseComponent suffix:d;
#else
    private (ChatText) String displayName:b;
    private (ChatText) String prefix:c;
    private (ChatText) String suffix:d;
#endif
    private String visibility:e;
#if version >= 1.13
    private optional String collisionRule:f;
    private (org.bukkit.ChatColor) EnumChatFormat color:g;
    private final Collection<String> players:h;
    private int mode:i;
    private int friendlyFire:j;
#elseif version >= 1.9
    private optional String collisionRule:f;
    private (org.bukkit.ChatColor) int color:g;
    private final Collection<String> players:h;
    private int mode:i;
    private int friendlyFire:j;
#else
    private optional String collisionRule:###;
    private (org.bukkit.ChatColor) int color:f;
    private final Collection<String> players:g;
    private int mode:h;
    private int friendlyFire:i;
#endif

    public (PacketPlayOutScoreboardTeamHandle) PacketPlayOutScoreboardTeam();

    <code>
    public void setCollisionRule(String rule) {
        if (T.collisionRule.isAvailable()) {
            T.collisionRule.set(getRaw(), rule);
        }
    }

    public String getCollisionRule() {
        if (T.collisionRule.isAvailable()) {
            return T.collisionRule.get(getRaw());
        } else {
            return "always";
        }
    }
    </code>
}

class PacketPlayInSettings extends Packet {
#if version >= 1.16
    public String locale;
#else
    private String locale:a;
#endif
#if fieldexists net.minecraft.server.PacketPlayInSettings public int viewDistance
    public int view:viewDistance;
#else
    private int view:b;
#endif
    private (Object) EntityHuman.EnumChatVisibility chatVisibility:c;
    private boolean enableColors:d;
    private int modelPartFlags:e;
    private optional (HumanHand) EnumMainHand mainHand:f;

    <code>
    public HumanHand getMainHand() {
        if (T.mainHand.isAvailable()) {
            return T.mainHand.get(getRaw());
        } else {
            return HumanHand.RIGHT;
        }
    }

    public void setMainHand(HumanHand mainHand) {
        if (T.mainHand.isAvailable()) {
            T.mainHand.set(getRaw(), mainHand);
        }
    }
    </code>
}

// Changed completely on MC 1.13
// class PacketPlayInTabComplete extends Packet {
//     private String text:a;
// #if version >= 1.9
//     private optional boolean assumeCommand:b;
//     private (IntVector3) BlockPosition position:c;
// #else
//     private optional boolean assumeCommand:###;
//     private (IntVector3) BlockPosition position:b;
// #endif
// }

class PacketPlayInResourcePackStatus extends Packet {
    private optional String message:a;
#if version >= 1.9
    public (Object) PacketPlayInResourcePackStatus.EnumResourcePackStatus status;
#else
    public (Object) PacketPlayInResourcePackStatus.EnumResourcePackStatus status:b;
#endif
}

class PacketPlayInSetCreativeSlot extends Packet {
    private int slot;
    private (org.bukkit.inventory.ItemStack) ItemStack item:b;
}

class PacketPlayOutEntityMetadata extends Packet {
    private int entityId:a;
#if version >= 1.9
    private (List<com.bergerkiller.bukkit.common.wrappers.DataWatcher.Item<Object>>) List<DataWatcher.Item<?>> metadataItems:b;
#else
    private (List<com.bergerkiller.bukkit.common.wrappers.DataWatcher.Item<Object>>) List<DataWatcher.WatchableObject> metadataItems:b;
#endif

    public (PacketPlayOutEntityMetadataHandle) PacketPlayOutEntityMetadata(int entityId, (com.bergerkiller.bukkit.common.wrappers.DataWatcher) DataWatcher datawatcher, boolean includeUnchangedData);

    <code>
    @Override
    public com.bergerkiller.bukkit.common.protocol.PacketType getPacketType() {
        return com.bergerkiller.bukkit.common.protocol.PacketType.OUT_ENTITY_METADATA;
    }
    </code>
}

class PacketPlayOutUpdateAttributes extends Packet {
    private int entityId:a;

    public static (PacketPlayOutUpdateAttributesHandle) PacketPlayOutUpdateAttributes createNew(int entityId, (java.util.Collection<AttributeModifiableHandle>) java.util.Collection<AttributeModifiable> attributes) {
        return new PacketPlayOutUpdateAttributes(entityId, attributes);
    }

    public static (PacketPlayOutUpdateAttributesHandle) PacketPlayOutUpdateAttributes createZeroMaxHealth(int entityId) {
#if version >= 1.16
        // Internal code uses a Consumer for callbacks, so no need to create a proxy for that
        java.util.function.Consumer callback = com.bergerkiller.bukkit.common.utils.LogicUtil.noopConsumer();
        AttributeModifiable attribute = new AttributeModifiable(GenericAttributes.MAX_HEALTH, callback);
#else
        // Internal code calls a callback on this instance, so we need a dummy one to catch that
        AttributeMapBase attributeMapBase = (AttributeMapBase) com.bergerkiller.bukkit.common.internal.proxy.DummyAttributeMapBase.INSTANCE;

        // Create a modifiable attribute for MAX_HEALTH, and set the value to 0
  #if version >= 1.14
        AttributeModifiable attribute = new AttributeModifiable(attributeMapBase, GenericAttributes.MAX_HEALTH);
  #else
        AttributeModifiable attribute = new AttributeModifiable(attributeMapBase, GenericAttributes.maxHealth);
  #endif
#endif
        attribute.setValue(0.0);

        // Create packet sending just this one attribute
        java.util.Collection attributes = java.util.Collections.singleton(attribute);
        return new PacketPlayOutUpdateAttributes(entityId, attributes);
    }
}

class PacketPlayInUpdateSign extends Packet {
    private (IntVector3) BlockPosition position:a;
#if version >= 1.9
    private (ChatText[]) String[] lines:b;
#else
    private (ChatText[]) IChatBaseComponent[] lines:b;
#endif
}

class PacketPlayInWindowClick extends Packet {
    private int windowId:a;
    private int slot;
    private int button;
    private short action:d;
    private (org.bukkit.inventory.ItemStack) ItemStack item;
#if version >= 1.9
    private (com.bergerkiller.bukkit.common.wrappers.InventoryClickType) InventoryClickType mode:shift;
#else
    private (com.bergerkiller.bukkit.common.wrappers.InventoryClickType) int mode:shift;
#endif
}

// Since MC 1.9
optional class PacketPlayInTeleportAccept extends Packet {
    private int teleportId:a;
}

// Only <= MC 1.8.8
optional class PacketPlayOutUpdateSign {
    private (org.bukkit.World) World world:a;
    private (IntVector3) BlockPosition position:b;
    private (ChatText[]) IChatBaseComponent[] lines:c;
}

class PacketPlayOutWorldParticles {
    // TODO: Create a common interface for particle + data
    // Since 1.13 there is a ParticleParam with many different types
    // Best option would be coming up with a proxy similar to this for <= 1.12.2
#if version >= 1.15
    #require net.minecraft.server.PacketPlayOutWorldParticles private double pos_x:a;
    #require net.minecraft.server.PacketPlayOutWorldParticles private double pos_y:b;
    #require net.minecraft.server.PacketPlayOutWorldParticles private double pos_z:c;
    private float randomX:d;
    private float randomY:e;
    private float randomZ:f;
    private float speed:g;
    private int count:h;
    private boolean longDistance:i;
    private unknown ParticleParam j;
#elseif version >= 1.13
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_x:a;
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_y:b;
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_z:c;
    private float randomX:d;
    private float randomY:e;
    private float randomZ:f;
    private float speed:g;
    private int count:h;
    private boolean longDistance:i;
    private unknown ParticleParam j;
#else
    private unknown EnumParticle a;
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_x:b;
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_y:c;
    #require net.minecraft.server.PacketPlayOutWorldParticles private float pos_z:d;
    private float randomX:e;
    private float randomY:f;
    private float randomZ:g;
    private float speed:h;
    private int count:i;
    private boolean longDistance:j;
    private unknown int[] k;
#endif

    public double getX() {
        return (double) instance#pos_x;
    }

    public double getY() {
        return (double) instance#pos_y;
    }

    public double getZ() {
        return (double) instance#pos_z;
    }

#if version >= 1.15
    public void setX(double x) {
        instance#pos_x = x;
    }

    public void setY(double y) {
        instance#pos_y = y;
    }

    public void setZ(double z) {
        instance#pos_z = z;
    }
#else
    public void setX(double x) {
        instance#pos_x = (float)x;
    }

    public void setY(double y) {
        instance#pos_y = (float)y;
    }

    public void setZ(double z) {
        instance#pos_z = (float)z;
    }
#endif
}

class PacketPlayOutScoreboardObjective {
#if version >= 1.13
    private String name:a;
    private (ChatText) IChatBaseComponent displayName:b;
    private (Object) IScoreboardCriteria.EnumScoreboardHealthDisplay criteria:c;
    private int action:d;
#else
    private String name:a;
    private (ChatText) String displayName:b;
    private (Object) IScoreboardCriteria.EnumScoreboardHealthDisplay criteria:c;
    private int action:d;
#endif
}