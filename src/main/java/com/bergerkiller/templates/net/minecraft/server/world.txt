package net.minecraft.server;

import com.bergerkiller.bukkit.common.wrappers.BlockData;
import com.bergerkiller.bukkit.common.bases.IntVector3;

import com.bergerkiller.generated.net.minecraft.server.IDataManagerHandle;
import com.bergerkiller.generated.net.minecraft.server.AxisAlignedBBHandle;
import com.bergerkiller.generated.net.minecraft.server.ChunkHandle;
import com.bergerkiller.generated.net.minecraft.server.WorldServerHandle;
import com.bergerkiller.generated.net.minecraft.server.WorldDataHandle;
import com.bergerkiller.generated.net.minecraft.server.WorldTypeHandle;
import com.bergerkiller.generated.net.minecraft.server.PlayerChunkMapHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityPlayerHandle;
import com.bergerkiller.generated.net.minecraft.server.EntityHumanHandle;
import com.bergerkiller.generated.net.minecraft.server.MethodProfilerHandle;
import com.bergerkiller.generated.net.minecraft.server.BiomeBaseHandle.BiomeMetaHandle;
import com.bergerkiller.generated.net.minecraft.server.WorldProviderHandle;
import com.bergerkiller.generated.net.minecraft.server.TileEntityHandle;
import com.bergerkiller.generated.net.minecraft.server.ChunkProviderServerHandle;
import com.bergerkiller.generated.net.minecraft.server.BiomeBaseHandle.BiomeMetaHandle;
import com.bergerkiller.generated.net.minecraft.server.MovingObjectPositionHandle;
import com.bergerkiller.generated.net.minecraft.server.RegionFileHandle;
import com.bergerkiller.generated.net.minecraft.server.IWorldAccessHandle;
import com.bergerkiller.generated.net.minecraft.server.MinecraftServerHandle;

class World {
    /* protected final (IntHashMap<EntityHandle>) IntHashMap<Entity> entitiesById; */

    public final (List<EntityHandle>) List<Entity> entityList;
    public optional final (List<TileEntityHandle>) List<TileEntity> tileEntityList;
    public final (List<EntityHumanHandle>) List<EntityHuman> players;
    public final Random random;
    public (WorldProviderHandle) WorldProvider worldProvider;
    protected (Object) NavigationListener navigationListener:t;
    protected (List<IWorldAccessHandle>) List<IWorldAccess> accessList:u;
    protected (Object) IChunkProvider chunkProvider;
    public final (MethodProfilerHandle) MethodProfiler methodProfiler;

    private final (org.bukkit.World) org.bukkit.craftbukkit.CraftWorld bukkitWorld:world;
    public boolean keepSpawnInMemory;

    public (org.bukkit.World) org.bukkit.craftbukkit.CraftWorld getWorld();

    public (org.bukkit.Server) org.bukkit.craftbukkit.CraftServer getServer();

    public (BlockData) IBlockData getBlockData:getType((IntVector3) BlockPosition blockposition);

    public boolean setBlockData:setTypeAndData((IntVector3) BlockPosition blockposition, (BlockData) IBlockData iblockdata, int updateFlags);

    public long getTime();

    // >= 1.11.2
    private optional boolean getBlockCollisions:a((EntityHandle) Entity entity, (AxisAlignedBBHandle) AxisAlignedBB bounds, boolean flag, (List<AxisAlignedBBHandle>) List<AxisAlignedBB> list);
    // <= 1.10.2
    public optional (List<AxisAlignedBBHandle>) List<AxisAlignedBB> getBlockCollisions_old:getCubes((EntityHandle) Entity entity, (AxisAlignedBBHandle) AxisAlignedBB axisalignedbb);

    public (List<?>) List<T extends Entity> getRawEntitiesOfType:a((Class<?>) Class<? extends Entity> rawType, (AxisAlignedBBHandle) AxisAlignedBB bounds);

    public (List<AxisAlignedBBHandle>) List<AxisAlignedBB> getCubes((EntityHandle) Entity entity, (AxisAlignedBBHandle) AxisAlignedBB axisalignedbb);

    public (List<EntityHandle>) List<Entity> getEntities((EntityHandle) Entity entity, (AxisAlignedBBHandle) AxisAlignedBB axisalignedbb);

    public (TileEntityHandle) TileEntity getTileEntity((IntVector3) BlockPosition blockposition);

    public (WorldDataHandle) WorldData getWorldData();

#if version >= 1.11.2
    public boolean isBurnArea:e((AxisAlignedBBHandle) AxisAlignedBB bounds);
#else
    public boolean isBurnArea:f((AxisAlignedBBHandle) AxisAlignedBB bounds);
#endif

    public void removeEntity((EntityHandle) Entity entity);

    public boolean addEntity((EntityHandle) Entity entity);

    public (IDataManagerHandle) IDataManager getDataManager();

    public float getExplosionFactor:a((org.bukkit.util.Vector) Vec3D vec3d, (AxisAlignedBBHandle) AxisAlignedBB bounds);

    public boolean areChunksLoaded((IntVector3) BlockPosition blockposition, int distance);

    public (MovingObjectPositionHandle) MovingObjectPosition rayTrace((org.bukkit.util.Vector) Vec3D point1, (org.bukkit.util.Vector) Vec3D point2, boolean flag);

    public void applyPhysics((IntVector3) BlockPosition position, (BlockData) Block causeType, boolean self);

    protected abstract boolean isChunkLoaded(int cx, int cz, boolean flag);

    <code>
    public org.bukkit.World toBukkit() {
        return com.bergerkiller.bukkit.common.conversion.Conversion.toWorld.convert(instance);
    }

    public static WorldHandle fromBukkit(org.bukkit.World world) {
        return createHandle(com.bergerkiller.bukkit.common.conversion.Conversion.toWorldHandle.convert(world));
    }
    </code>
}

class WorldServer extends World {
    private final (MinecraftServerHandle) MinecraftServer minecraftServer:server;
    public (com.bergerkiller.bukkit.common.wrappers.EntityTracker) EntityTracker entityTracker:tracker;
    private final (PlayerChunkMapHandle) PlayerChunkMap playerChunkMapField:manager;
    private final (Map<java.util.UUID, EntityHandle>) Map<java.util.UUID, Entity> entitiesByUUID;

    public (PlayerChunkMapHandle) PlayerChunkMap getPlayerChunkMap();

    public (ChunkProviderServerHandle) ChunkProviderServer getChunkProviderServer();

    public void saveLevel();

    <code>
    public static WorldServerHandle fromBukkit(org.bukkit.World world) {
        return createHandle(com.bergerkiller.bukkit.common.conversion.Conversion.toWorldHandle.convert(world));
    }
    </code>
}

class ChunkProviderServer {
    private final (Object) IChunkLoader chunkLoader;
    public final (WorldServerHandle) WorldServer world;

    public (List<BiomeMetaHandle>) List<BiomeBase.BiomeMeta> getBiomeSpawnInfo:a((Object) EnumCreatureType enumcreaturetype, (IntVector3) BlockPosition position);

    public (ChunkHandle) Chunk getChunkIfLoaded(int cx, int cz);

    public (ChunkHandle) Chunk getChunkAt(int cx, int cz);

    public void saveChunk((ChunkHandle) Chunk chunk);

    public boolean isLoaded(int cx, int cz);
}

class PlayerChunkMap {
    public boolean isChunkEntered:a((EntityPlayerHandle) EntityPlayer entityplayer, int chunkX, int chunkZ);
}

class WorldData {
    public (WorldTypeHandle) WorldType getType();

    public void setClearTimer:i(int ticks);
}

class WorldType {
    public int getDimension:g();
}

class WorldProvider {
    public boolean int_skyLightProperty:m();

<code>
    private static final boolean _darkInverted = com.bergerkiller.bukkit.common.Common.evaluateMCVersion(">=", "1.11.2");

    public boolean hasSkyLight() {
        return T.int_skyLightProperty.invoke(instance).booleanValue() != _darkInverted;
    }

    public boolean isDarkWorld() {
        return !hasSkyLight();
    }
</code>
}

class WeightedRandom {

    class WeightedRandom.WeightedRandomChoice {
        protected int chance:a;
    }
}

class BiomeBase {

    class BiomeBase.BiomeMeta extends WeightedRandom.WeightedRandomChoice {
        public (java.lang.Class<?>) java.lang.Class<? extends EntityInsentient> entityClass:b;
        public int minSpawnCount:c;
        public int maxSpawnCount:d;

        public (BiomeMetaHandle) BiomeBase.BiomeMeta((java.lang.Class<?>) java.lang.Class<? extends EntityInsentient> entityClass, int x, int y, int z);
    }

}

interface IWorldAccess {
    public abstract void onEntityAdded:a((EntityHandle) Entity entity);

    public abstract void onEntityRemoved:b((EntityHandle) Entity entity);
}

interface IDataManager {

}

class WorldNBTStorage extends IDataManager {
    public java.io.File getPlayerDir();
}

class MovingObjectPosition {
    public (org.bukkit.util.Vector) Vec3D pos;
}

class RegionFile {
    private final java.io.File file:b;
    private java.io.RandomAccessFile stream:c;

    public (RegionFileHandle) RegionFile(java.io.File file);

    public void close:c();
    public boolean chunkExists:c(int cx, int cz);
}

class RegionFileCache {
    public static final (Map<java.io.File, RegionFileHandle>) Map<java.io.File, RegionFile> FILES:a;
}

class ChunkRegionLoader {
#if version >= 1.12
    public optional boolean opt_chunkExists:chunkExists(int cx, int cz);
#else
    public optional boolean opt_chunkExists:a(int cx, int cz);
#endif

    // <= 1.10.2
    public optional boolean opt_chunkExists_old:chunkExists((org.bukkit.World) World world, int cx, int cz);

<code>
    public boolean chunkExists(org.bukkit.World world, int cx, int cz) {
        if (T.opt_chunkExists_old.isAvailable()) {
            return T.opt_chunkExists_old.invoke(instance, world, cx, cz);
        } else {
            return T.opt_chunkExists.invoke(instance, cx, cz);
        }
    }
</code>
}